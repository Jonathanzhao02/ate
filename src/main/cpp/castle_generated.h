// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CASTLE_COM_TOKERA_ATE_DAO_MSG_H_
#define FLATBUFFERS_GENERATED_CASTLE_COM_TOKERA_ATE_DAO_MSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace com {
namespace tokera {
namespace ate {
namespace dao {
namespace msg {

struct MessageSecurityGate;

struct MessageSecurityCastle;

struct MessageSecurityGate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEYHASH = 4,
    VT_ENCRYPTEDTEXT = 6
  };
  const flatbuffers::String *publicKeyHash() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEYHASH);
  }
  const flatbuffers::Vector<int8_t> *encryptedText() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ENCRYPTEDTEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBLICKEYHASH) &&
           verifier.VerifyString(publicKeyHash()) &&
           VerifyOffset(verifier, VT_ENCRYPTEDTEXT) &&
           verifier.VerifyVector(encryptedText()) &&
           verifier.EndTable();
  }
};

struct MessageSecurityGateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKeyHash(flatbuffers::Offset<flatbuffers::String> publicKeyHash) {
    fbb_.AddOffset(MessageSecurityGate::VT_PUBLICKEYHASH, publicKeyHash);
  }
  void add_encryptedText(flatbuffers::Offset<flatbuffers::Vector<int8_t>> encryptedText) {
    fbb_.AddOffset(MessageSecurityGate::VT_ENCRYPTEDTEXT, encryptedText);
  }
  explicit MessageSecurityGateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageSecurityGateBuilder &operator=(const MessageSecurityGateBuilder &);
  flatbuffers::Offset<MessageSecurityGate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageSecurityGate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageSecurityGate> CreateMessageSecurityGate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKeyHash = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> encryptedText = 0) {
  MessageSecurityGateBuilder builder_(_fbb);
  builder_.add_encryptedText(encryptedText);
  builder_.add_publicKeyHash(publicKeyHash);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageSecurityGate> CreateMessageSecurityGateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKeyHash = nullptr,
    const std::vector<int8_t> *encryptedText = nullptr) {
  return com::tokera::ate::dao::msg::CreateMessageSecurityGate(
      _fbb,
      publicKeyHash ? _fbb.CreateString(publicKeyHash) : 0,
      encryptedText ? _fbb.CreateVector<int8_t>(*encryptedText) : 0);
}

struct MessageSecurityCastle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_GATES = 6
  };
  const com::tokera::ate::dao::ObjId *id() const {
    return GetStruct<const com::tokera::ate::dao::ObjId *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MessageSecurityGate>> *gates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MessageSecurityGate>> *>(VT_GATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<com::tokera::ate::dao::ObjId>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_GATES) &&
           verifier.VerifyVector(gates()) &&
           verifier.VerifyVectorOfTables(gates()) &&
           verifier.EndTable();
  }
};

struct MessageSecurityCastleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const com::tokera::ate::dao::ObjId *id) {
    fbb_.AddStruct(MessageSecurityCastle::VT_ID, id);
  }
  void add_gates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MessageSecurityGate>>> gates) {
    fbb_.AddOffset(MessageSecurityCastle::VT_GATES, gates);
  }
  explicit MessageSecurityCastleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageSecurityCastleBuilder &operator=(const MessageSecurityCastleBuilder &);
  flatbuffers::Offset<MessageSecurityCastle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageSecurityCastle>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageSecurityCastle> CreateMessageSecurityCastle(
    flatbuffers::FlatBufferBuilder &_fbb,
    const com::tokera::ate::dao::ObjId *id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MessageSecurityGate>>> gates = 0) {
  MessageSecurityCastleBuilder builder_(_fbb);
  builder_.add_gates(gates);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageSecurityCastle> CreateMessageSecurityCastleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const com::tokera::ate::dao::ObjId *id = 0,
    const std::vector<flatbuffers::Offset<MessageSecurityGate>> *gates = nullptr) {
  return com::tokera::ate::dao::msg::CreateMessageSecurityCastle(
      _fbb,
      id,
      gates ? _fbb.CreateVector<flatbuffers::Offset<MessageSecurityGate>>(*gates) : 0);
}

}  // namespace msg
}  // namespace dao
}  // namespace ate
}  // namespace tokera
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_CASTLE_COM_TOKERA_ATE_DAO_MSG_H_
