// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATA_COM_TOKERA_ATE_DAO_MSG_H_
#define FLATBUFFERS_GENERATED_DATA_COM_TOKERA_ATE_DAO_MSG_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace com {
namespace tokera {
namespace ate {
namespace dao {
namespace msg {

struct MessageDataHeader;

struct MessageDataDigest;

struct MessageData;

struct MessageSync;

struct MessageDataHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_VERSION = 6,
    VT_PARENTID = 8,
    VT_PREVIOUSVERSION = 10,
    VT_MERGES = 12,
    VT_ENCRYPTKEYHASH = 14,
    VT_INHERITREAD = 16,
    VT_INHERITWRITE = 18,
    VT_PAYLOADCLAZZ = 20,
    VT_ALLOWREAD = 22,
    VT_ALLOWWRITE = 24,
    VT_IMPLICITAUTHORITY = 26
  };
  const com::tokera::ate::dao::ObjId *id() const {
    return GetStruct<const com::tokera::ate::dao::ObjId *>(VT_ID);
  }
  const com::tokera::ate::dao::ObjId *version() const {
    return GetStruct<const com::tokera::ate::dao::ObjId *>(VT_VERSION);
  }
  const com::tokera::ate::dao::ObjId *parentId() const {
    return GetStruct<const com::tokera::ate::dao::ObjId *>(VT_PARENTID);
  }
  const com::tokera::ate::dao::ObjId *previousVersion() const {
    return GetStruct<const com::tokera::ate::dao::ObjId *>(VT_PREVIOUSVERSION);
  }
  const flatbuffers::Vector<const com::tokera::ate::dao::ObjId *> *merges() const {
    return GetPointer<const flatbuffers::Vector<const com::tokera::ate::dao::ObjId *> *>(VT_MERGES);
  }
  const flatbuffers::String *encryptKeyHash() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCRYPTKEYHASH);
  }
  bool inheritRead() const {
    return GetField<uint8_t>(VT_INHERITREAD, 1) != 0;
  }
  bool inheritWrite() const {
    return GetField<uint8_t>(VT_INHERITWRITE, 1) != 0;
  }
  const flatbuffers::String *payloadClazz() const {
    return GetPointer<const flatbuffers::String *>(VT_PAYLOADCLAZZ);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *allowRead() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALLOWREAD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *allowWrite() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALLOWWRITE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *implicitAuthority() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_IMPLICITAUTHORITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<com::tokera::ate::dao::ObjId>(verifier, VT_ID) &&
           VerifyField<com::tokera::ate::dao::ObjId>(verifier, VT_VERSION) &&
           VerifyField<com::tokera::ate::dao::ObjId>(verifier, VT_PARENTID) &&
           VerifyField<com::tokera::ate::dao::ObjId>(verifier, VT_PREVIOUSVERSION) &&
           VerifyOffset(verifier, VT_MERGES) &&
           verifier.VerifyVector(merges()) &&
           VerifyOffset(verifier, VT_ENCRYPTKEYHASH) &&
           verifier.VerifyString(encryptKeyHash()) &&
           VerifyField<uint8_t>(verifier, VT_INHERITREAD) &&
           VerifyField<uint8_t>(verifier, VT_INHERITWRITE) &&
           VerifyOffset(verifier, VT_PAYLOADCLAZZ) &&
           verifier.VerifyString(payloadClazz()) &&
           VerifyOffset(verifier, VT_ALLOWREAD) &&
           verifier.VerifyVector(allowRead()) &&
           verifier.VerifyVectorOfStrings(allowRead()) &&
           VerifyOffset(verifier, VT_ALLOWWRITE) &&
           verifier.VerifyVector(allowWrite()) &&
           verifier.VerifyVectorOfStrings(allowWrite()) &&
           VerifyOffset(verifier, VT_IMPLICITAUTHORITY) &&
           verifier.VerifyVector(implicitAuthority()) &&
           verifier.VerifyVectorOfStrings(implicitAuthority()) &&
           verifier.EndTable();
  }
};

struct MessageDataHeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const com::tokera::ate::dao::ObjId *id) {
    fbb_.AddStruct(MessageDataHeader::VT_ID, id);
  }
  void add_version(const com::tokera::ate::dao::ObjId *version) {
    fbb_.AddStruct(MessageDataHeader::VT_VERSION, version);
  }
  void add_parentId(const com::tokera::ate::dao::ObjId *parentId) {
    fbb_.AddStruct(MessageDataHeader::VT_PARENTID, parentId);
  }
  void add_previousVersion(const com::tokera::ate::dao::ObjId *previousVersion) {
    fbb_.AddStruct(MessageDataHeader::VT_PREVIOUSVERSION, previousVersion);
  }
  void add_merges(flatbuffers::Offset<flatbuffers::Vector<const com::tokera::ate::dao::ObjId *>> merges) {
    fbb_.AddOffset(MessageDataHeader::VT_MERGES, merges);
  }
  void add_encryptKeyHash(flatbuffers::Offset<flatbuffers::String> encryptKeyHash) {
    fbb_.AddOffset(MessageDataHeader::VT_ENCRYPTKEYHASH, encryptKeyHash);
  }
  void add_inheritRead(bool inheritRead) {
    fbb_.AddElement<uint8_t>(MessageDataHeader::VT_INHERITREAD, static_cast<uint8_t>(inheritRead), 1);
  }
  void add_inheritWrite(bool inheritWrite) {
    fbb_.AddElement<uint8_t>(MessageDataHeader::VT_INHERITWRITE, static_cast<uint8_t>(inheritWrite), 1);
  }
  void add_payloadClazz(flatbuffers::Offset<flatbuffers::String> payloadClazz) {
    fbb_.AddOffset(MessageDataHeader::VT_PAYLOADCLAZZ, payloadClazz);
  }
  void add_allowRead(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> allowRead) {
    fbb_.AddOffset(MessageDataHeader::VT_ALLOWREAD, allowRead);
  }
  void add_allowWrite(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> allowWrite) {
    fbb_.AddOffset(MessageDataHeader::VT_ALLOWWRITE, allowWrite);
  }
  void add_implicitAuthority(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> implicitAuthority) {
    fbb_.AddOffset(MessageDataHeader::VT_IMPLICITAUTHORITY, implicitAuthority);
  }
  explicit MessageDataHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageDataHeaderBuilder &operator=(const MessageDataHeaderBuilder &);
  flatbuffers::Offset<MessageDataHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageDataHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageDataHeader> CreateMessageDataHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    const com::tokera::ate::dao::ObjId *id = 0,
    const com::tokera::ate::dao::ObjId *version = 0,
    const com::tokera::ate::dao::ObjId *parentId = 0,
    const com::tokera::ate::dao::ObjId *previousVersion = 0,
    flatbuffers::Offset<flatbuffers::Vector<const com::tokera::ate::dao::ObjId *>> merges = 0,
    flatbuffers::Offset<flatbuffers::String> encryptKeyHash = 0,
    bool inheritRead = true,
    bool inheritWrite = true,
    flatbuffers::Offset<flatbuffers::String> payloadClazz = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> allowRead = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> allowWrite = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> implicitAuthority = 0) {
  MessageDataHeaderBuilder builder_(_fbb);
  builder_.add_implicitAuthority(implicitAuthority);
  builder_.add_allowWrite(allowWrite);
  builder_.add_allowRead(allowRead);
  builder_.add_payloadClazz(payloadClazz);
  builder_.add_encryptKeyHash(encryptKeyHash);
  builder_.add_merges(merges);
  builder_.add_previousVersion(previousVersion);
  builder_.add_parentId(parentId);
  builder_.add_version(version);
  builder_.add_id(id);
  builder_.add_inheritWrite(inheritWrite);
  builder_.add_inheritRead(inheritRead);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageDataHeader> CreateMessageDataHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const com::tokera::ate::dao::ObjId *id = 0,
    const com::tokera::ate::dao::ObjId *version = 0,
    const com::tokera::ate::dao::ObjId *parentId = 0,
    const com::tokera::ate::dao::ObjId *previousVersion = 0,
    const std::vector<com::tokera::ate::dao::ObjId> *merges = nullptr,
    const char *encryptKeyHash = nullptr,
    bool inheritRead = true,
    bool inheritWrite = true,
    const char *payloadClazz = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *allowRead = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *allowWrite = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *implicitAuthority = nullptr) {
  return com::tokera::ate::dao::msg::CreateMessageDataHeader(
      _fbb,
      id,
      version,
      parentId,
      previousVersion,
      merges ? _fbb.CreateVectorOfStructs<com::tokera::ate::dao::ObjId>(*merges) : 0,
      encryptKeyHash ? _fbb.CreateString(encryptKeyHash) : 0,
      inheritRead,
      inheritWrite,
      payloadClazz ? _fbb.CreateString(payloadClazz) : 0,
      allowRead ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*allowRead) : 0,
      allowWrite ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*allowWrite) : 0,
      implicitAuthority ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*implicitAuthority) : 0);
}

struct MessageDataDigest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SEED = 4,
    VT_SIGNATURE1 = 6,
    VT_SIGNATURE2 = 8,
    VT_DIGEST = 10,
    VT_PUBLICKEYHASH = 12
  };
  const flatbuffers::Vector<int8_t> *seed() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SEED);
  }
  const flatbuffers::Vector<int8_t> *signature1() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SIGNATURE1);
  }
  const flatbuffers::Vector<int8_t> *signature2() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SIGNATURE2);
  }
  const flatbuffers::Vector<int8_t> *digest() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DIGEST);
  }
  const flatbuffers::String *publicKeyHash() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEYHASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEED) &&
           verifier.VerifyVector(seed()) &&
           VerifyOffset(verifier, VT_SIGNATURE1) &&
           verifier.VerifyVector(signature1()) &&
           VerifyOffset(verifier, VT_SIGNATURE2) &&
           verifier.VerifyVector(signature2()) &&
           VerifyOffset(verifier, VT_DIGEST) &&
           verifier.VerifyVector(digest()) &&
           VerifyOffset(verifier, VT_PUBLICKEYHASH) &&
           verifier.VerifyString(publicKeyHash()) &&
           verifier.EndTable();
  }
};

struct MessageDataDigestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(flatbuffers::Offset<flatbuffers::Vector<int8_t>> seed) {
    fbb_.AddOffset(MessageDataDigest::VT_SEED, seed);
  }
  void add_signature1(flatbuffers::Offset<flatbuffers::Vector<int8_t>> signature1) {
    fbb_.AddOffset(MessageDataDigest::VT_SIGNATURE1, signature1);
  }
  void add_signature2(flatbuffers::Offset<flatbuffers::Vector<int8_t>> signature2) {
    fbb_.AddOffset(MessageDataDigest::VT_SIGNATURE2, signature2);
  }
  void add_digest(flatbuffers::Offset<flatbuffers::Vector<int8_t>> digest) {
    fbb_.AddOffset(MessageDataDigest::VT_DIGEST, digest);
  }
  void add_publicKeyHash(flatbuffers::Offset<flatbuffers::String> publicKeyHash) {
    fbb_.AddOffset(MessageDataDigest::VT_PUBLICKEYHASH, publicKeyHash);
  }
  explicit MessageDataDigestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageDataDigestBuilder &operator=(const MessageDataDigestBuilder &);
  flatbuffers::Offset<MessageDataDigest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageDataDigest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageDataDigest> CreateMessageDataDigest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> seed = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> signature1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> signature2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> digest = 0,
    flatbuffers::Offset<flatbuffers::String> publicKeyHash = 0) {
  MessageDataDigestBuilder builder_(_fbb);
  builder_.add_publicKeyHash(publicKeyHash);
  builder_.add_digest(digest);
  builder_.add_signature2(signature2);
  builder_.add_signature1(signature1);
  builder_.add_seed(seed);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageDataDigest> CreateMessageDataDigestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *seed = nullptr,
    const std::vector<int8_t> *signature1 = nullptr,
    const std::vector<int8_t> *signature2 = nullptr,
    const std::vector<int8_t> *digest = nullptr,
    const char *publicKeyHash = nullptr) {
  return com::tokera::ate::dao::msg::CreateMessageDataDigest(
      _fbb,
      seed ? _fbb.CreateVector<int8_t>(*seed) : 0,
      signature1 ? _fbb.CreateVector<int8_t>(*signature1) : 0,
      signature2 ? _fbb.CreateVector<int8_t>(*signature2) : 0,
      digest ? _fbb.CreateVector<int8_t>(*digest) : 0,
      publicKeyHash ? _fbb.CreateString(publicKeyHash) : 0);
}

struct MessageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAYLOAD = 4,
    VT_HEADER = 6,
    VT_DIGEST = 8
  };
  const flatbuffers::Vector<int8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_PAYLOAD);
  }
  const MessageDataHeader *header() const {
    return GetPointer<const MessageDataHeader *>(VT_HEADER);
  }
  const MessageDataDigest *digest() const {
    return GetPointer<const MessageDataDigest *>(VT_DIGEST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_DIGEST) &&
           verifier.VerifyTable(digest()) &&
           verifier.EndTable();
  }
};

struct MessageDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<int8_t>> payload) {
    fbb_.AddOffset(MessageData::VT_PAYLOAD, payload);
  }
  void add_header(flatbuffers::Offset<MessageDataHeader> header) {
    fbb_.AddOffset(MessageData::VT_HEADER, header);
  }
  void add_digest(flatbuffers::Offset<MessageDataDigest> digest) {
    fbb_.AddOffset(MessageData::VT_DIGEST, digest);
  }
  explicit MessageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageDataBuilder &operator=(const MessageDataBuilder &);
  flatbuffers::Offset<MessageData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageData> CreateMessageData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> payload = 0,
    flatbuffers::Offset<MessageDataHeader> header = 0,
    flatbuffers::Offset<MessageDataDigest> digest = 0) {
  MessageDataBuilder builder_(_fbb);
  builder_.add_digest(digest);
  builder_.add_header(header);
  builder_.add_payload(payload);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageData> CreateMessageDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *payload = nullptr,
    flatbuffers::Offset<MessageDataHeader> header = 0,
    flatbuffers::Offset<MessageDataDigest> digest = 0) {
  return com::tokera::ate::dao::msg::CreateMessageData(
      _fbb,
      payload ? _fbb.CreateVector<int8_t>(*payload) : 0,
      header,
      digest);
}

struct MessageSync FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TICKET1 = 4,
    VT_TICKET2 = 6
  };
  int64_t ticket1() const {
    return GetField<int64_t>(VT_TICKET1, 0);
  }
  int64_t ticket2() const {
    return GetField<int64_t>(VT_TICKET2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TICKET1) &&
           VerifyField<int64_t>(verifier, VT_TICKET2) &&
           verifier.EndTable();
  }
};

struct MessageSyncBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticket1(int64_t ticket1) {
    fbb_.AddElement<int64_t>(MessageSync::VT_TICKET1, ticket1, 0);
  }
  void add_ticket2(int64_t ticket2) {
    fbb_.AddElement<int64_t>(MessageSync::VT_TICKET2, ticket2, 0);
  }
  explicit MessageSyncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageSyncBuilder &operator=(const MessageSyncBuilder &);
  flatbuffers::Offset<MessageSync> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageSync>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageSync> CreateMessageSync(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ticket1 = 0,
    int64_t ticket2 = 0) {
  MessageSyncBuilder builder_(_fbb);
  builder_.add_ticket2(ticket2);
  builder_.add_ticket1(ticket1);
  return builder_.Finish();
}

}  // namespace msg
}  // namespace dao
}  // namespace ate
}  // namespace tokera
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_DATA_COM_TOKERA_ATE_DAO_MSG_H_
