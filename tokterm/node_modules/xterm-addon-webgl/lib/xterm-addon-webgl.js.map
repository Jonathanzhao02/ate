{"version":3,"sources":["webpack://WebglAddon/webpack/universalModuleDefinition","webpack://WebglAddon/webpack/bootstrap","webpack://WebglAddon//home/vsts/work/1/s/src/common/buffer/Constants.ts","webpack://WebglAddon/./src/WebglUtils.ts","webpack://WebglAddon/./src/atlas/CharAtlasUtils.ts","webpack://WebglAddon//home/vsts/work/1/s/src/browser/renderer/atlas/Constants.ts","webpack://WebglAddon//home/vsts/work/1/s/src/common/TypedArrayUtils.ts","webpack://WebglAddon/./src/WebglRenderer.ts","webpack://WebglAddon/./src/RenderModel.ts","webpack://WebglAddon/./src/ColorUtils.ts","webpack://WebglAddon/./src/renderLayer/BaseRenderLayer.ts","webpack://WebglAddon/./src/atlas/CharAtlasCache.ts","webpack://WebglAddon//home/vsts/work/1/s/src/common/buffer/CellData.ts","webpack://WebglAddon/./src/WebglAddon.ts","webpack://WebglAddon/./src/GlyphRenderer.ts","webpack://WebglAddon/./src/TypedArray.ts","webpack://WebglAddon/./src/renderLayer/LinkRenderLayer.ts","webpack://WebglAddon/./src/atlas/WebglCharAtlas.ts","webpack://WebglAddon/./src/renderLayer/CursorRenderLayer.ts","webpack://WebglAddon//home/vsts/work/1/s/src/common/input/TextDecoder.ts","webpack://WebglAddon//home/vsts/work/1/s/src/common/buffer/AttributeData.ts","webpack://WebglAddon/./src/RectangleRenderer.ts","webpack://WebglAddon//home/vsts/work/1/s/src/common/Lifecycle.ts","webpack://WebglAddon/./src/CharDataCompat.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DEFAULT_COLOR","DEFAULT_ATTR","CHAR_DATA_ATTR_INDEX","CHAR_DATA_CHAR_INDEX","CHAR_DATA_WIDTH_INDEX","CHAR_DATA_CODE_INDEX","NULL_CELL_CHAR","NULL_CELL_WIDTH","NULL_CELL_CODE","WHITESPACE_CELL_CHAR","WHITESPACE_CELL_WIDTH","WHITESPACE_CELL_CODE","createShader","gl","type","source","shader","throwIfFalsy","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","Error","PROJECTION_MATRIX","Float32Array","vertexSource","fragmentSource","program","createProgram","attachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","max","newLength","Math","min","length","newArray","NULL_COLOR","css","rgba","scaledCharWidth","scaledCharHeight","terminal","colors","clonedColors","foreground","background","cursor","cursorAccent","selection","ansi","slice","devicePixelRatio","fontFamily","getOption","fontSize","fontWeight","fontWeightBold","allowTransparency","a","b","colorCode","INVERTED_DEFAULT_COLOR","DIM_OPACITY","CHAR_ATLAS_CELL_SPACING","fillFallback","array","start","end","fill","result","constructor","set","INDICIES_PER_CELL","_terminal","_colors","preserveDrawingBuffer","_model","RenderModel","_core","_applyBgLuminanceBasedSelection","_renderLayers","LinkRenderLayer","screenElement","CursorRenderLayer","dimensions","scaledCellWidth","scaledCellHeight","scaledCharLeft","scaledCharTop","scaledCanvasWidth","scaledCanvasHeight","canvasWidth","canvasHeight","actualCellWidth","actualCellHeight","_devicePixelRatio","_updateDimensions","_canvas","document","createElement","contextAttributes","antialias","depth","_gl","getContext","appendChild","_rectangleRenderer","RectangleRenderer","_glyphRenderer","GlyphRenderer","onCharSizeChanged","dispose","this","forEach","removeChild","getLuminance","setColors","reset","_refreshCharAtlas","clear","onDevicePixelRatioChange","onResize","cols","rows","resize","width","height","style","setDimensions","onBlur","onFocus","onSelectionChanged","columnSelectMode","_updateSelectionModel","updateSelection","refresh","onCursorMove","onOptionsChanged","atlas","acquireCharAtlas","_charAtlas","warmUp","setAtlas","registerCharacterJoiner","handler","deregisterCharacterJoiner","joinerId","renderRows","onGridChanged","beginFrame","_updateModel","render","hasSelection","y","row","buffer","ydisp","line","lines","lineLengths","x","charData","chars","code","attr","getCompatAttr","cells","flags","bg","fg","temp","options","drawBoldTextInBrightColors","COMBINED_CHAR_BIT_MASK","updateCell","updateBackgrounds","viewportStartRow","viewportY","viewportEndRow","viewportCappedStartRow","viewportCappedEndRow","clearSelection","startCol","endCol","_charSizeService","floor","ceil","round","Disposable","WebglRenderer","RENDER_MODEL_INDICIES_PER_CELL","Uint32Array","indexCount","color","_container","id","zIndex","_alpha","_scaledCharWidth","_scaledCharHeight","_scaledCellWidth","_scaledCellHeight","_scaledCharLeft","_scaledCharTop","_currentGlyphIdentifier","bold","dim","italic","classList","add","toString","_initCanvas","_ctx","alpha","_clearAll","startRow","endRow","colorSet","_setTransparency","oldCanvas","cloneNode","replaceChild","_fillCells","fillRect","_fillBottomLineAtCells","_fillLeftLineAtCell","_strokeRectAtCell","lineWidth","strokeRect","clearRect","fillStyle","_clearCells","_fillCharTrueColor","cell","font","_getFont","textBaseline","_clipRow","fillText","getChars","beginPath","rect","clip","isBold","isItalic","BaseRenderLayer","charAtlasCache","newConfig","generateConfig","ownedByIndex","entry","ownedBy","indexOf","configEquals","config","splice","push","newEntry","WebglCharAtlas","index","content","combinedData","fromCharData","obj","CellData","setFromCharData","isCombined","getWidth","stringFromCodePoint","getCode","charCodeAt","combined","second","getAsCharData","AttributeData","_preserveDrawingBuffer","activate","element","renderService","_renderService","_colorManager","setRenderer","WebglAddon","vertexShaderSource","fragmentShaderSource","BYTES_PER_CELL","BYTES_PER_ELEMENT","_dimensions","_activeBuffer","_vertices","count","attributes","attributesBuffers","selectionAttributes","_program","_projectionLocation","getUniformLocation","_resolutionLocation","_textureLocation","_vertexArrayObject","createVertexArray","bindVertexArray","unitQuadVertices","unitQuadVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","unitQuadElementIndices","Uint8Array","elementIndicesBuffer","ELEMENT_ARRAY_BUFFER","_attributesBuffer","vertexAttribDivisor","_atlasTexture","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","_atlas","_updateCell","undefined","rasterizedGlyph","getRasterizedGlyphCombinedChar","getRasterizedGlyph","offset","size","texturePositionClipSpace","sizeClipSpace","model","lumi","_updateSelectionRange","startRowEndCol","middleRowsCount","getLine","getCell","char","viewport","canvas","newCount","renderModel","isSelectionVisible","useProgram","activeBuffer","bufferLength","si","sub","subarray","STREAM_DRAW","hasCanvasChanged","uniform1i","activeTexture","TEXTURE0","cacheCanvas","generateMipmap","uniformMatrix4fv","uniform2f","drawElementsInstanced","TRIANGLES","sliceFallback","container","linkifier","onLinkHover","e","_onLinkHover","onLinkLeave","_onLinkLeave","_state","_clearCurrentLink","x1","y1","middleRowCount","y2","x2","is256Color","TEXTURE_WIDTH","TEXTURE_HEIGHT","TEXTURE_CAPACITY","TRANSPARENT_COLOR","NULL_RASTERIZED_GLYPH","texturePosition","TMP_CANVAS_GLYPH_PADDING","_config","_didWarmUp","_cacheMap","_cacheMapCombined","_currentRowY","_currentRowX","_currentRowHeight","_workBoundingBox","top","left","bottom","right","_cacheCtx","_tmpCanvas","_tmpCtx","body","parentElement","_doWarmUp","_drawToCache","rasterizedGlyphSet","_getColorFromAnsiIndex","idx","_getBackgroundColor","_getForegroundColor","codeOrChars","String","fromCharCode","save","backgroundColor","globalCompositeOperation","fontStyle","globalAlpha","restore","imageData","getImageData","isEmpty","g","data","clearColor","_findGlyphBoundingBox","clippedImageData","_clipImageData","putImageData","boundingBox","found","alphaOffset","clippedData","Uint8ClampedArray","oldOffset","newOffset","ImageData","_cell","isFocused","_cursorRenderers","_renderBarCursor","_renderBlockCursor","_renderUnderlineCursor","_clearCursor","_cursorBlinkStateManager","pause","cursorY","resume","CursorBlinkStateManager","_render","restartBlinkAnimation","isPaused","triggeredByAnimationFrame","cursorState","cursorHidden","baseY","viewportRelativeCursorY","loadCell","cursorX","isTerminalFocused","cursorStyle","_renderBlurCursor","isCursorVisible","strokeStyle","_renderCallback","_restartInterval","_blinkStartTimeout","_blinkInterval","clearInterval","clearTimeout","_animationFrame","cancelAnimationFrame","_animationTimeRestarted","Date","now","requestAnimationFrame","timeToStart","setTimeout","time","setInterval","activeElement","textarea","hasFocus","codePoint","codepoint","_interim","decode","input","target","startPos","StringToUtf32","interim","byte1","byte2","byte3","byte4","discardInterim","cp","pos","tmp","missing","fourStop","Utf8ToUtf32","toColorRGB","fromColorRGB","clone","newObj","isInverse","isUnderline","isBlink","isInvisible","isDim","getFgColorMode","getBgColorMode","isFgRGB","isBgRGB","isFgPalette","isBgPalette","isFgDefault","isBgDefault","getFgColor","getBgColor","INDICES_PER_RECTANGLE","BYTES_PER_RECTANGLE","INITIAL_BUFFER_RECTANGLE_CAPACITY","_updateCachedColors","DYNAMIC_DRAW","_updateViewportRectangle","_bgFloat","_colorToFloat32Array","_selectionFloat","_addRectangleFloat","vertices","rectangleCount","currentStartX","currentBg","modelIndex","_updateRectangle","startX","endX","expandFloat32Array","_addRectangle","_disposables","_isDisposed","register","unregister","bufferLine"],"mappings":"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","file":"xterm-addon-webgl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebglAddon\"] = factory();\n\telse\n\t\troot[\"WebglAddon\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const DEFAULT_COLOR = 256;\nexport const DEFAULT_ATTR = (0 << 18) | (DEFAULT_COLOR << 9) | (256 << 0);\n\nexport const CHAR_DATA_ATTR_INDEX = 0;\nexport const CHAR_DATA_CHAR_INDEX = 1;\nexport const CHAR_DATA_WIDTH_INDEX = 2;\nexport const CHAR_DATA_CODE_INDEX = 3;\n\n/**\n * Null cell - a real empty cell (containing nothing).\n * Note that code should always be 0 for a null cell as\n * several test condition of the buffer line rely on this.\n */\nexport const NULL_CELL_CHAR = '';\nexport const NULL_CELL_WIDTH = 1;\nexport const NULL_CELL_CODE = 0;\n\n/**\n * Whitespace cell.\n * This is meant as a replacement for empty cells when needed\n * during rendering lines to preserve correct aligment.\n */\nexport const WHITESPACE_CELL_CHAR = ' ';\nexport const WHITESPACE_CELL_WIDTH = 1;\nexport const WHITESPACE_CELL_CODE = 32;\n\n/**\n * Bitmasks for accessing data in `content`.\n */\nexport const enum Content {\n  /**\n   * bit 1..21    codepoint, max allowed in UTF32 is 0x10FFFF (21 bits taken)\n   *              read:   `codepoint = content & Content.codepointMask;`\n   *              write:  `content |= codepoint & Content.codepointMask;`\n   *                      shortcut if precondition `codepoint <= 0x10FFFF` is met:\n   *                      `content |= codepoint;`\n   */\n  CODEPOINT_MASK = 0x1FFFFF,\n\n  /**\n   * bit 22       flag indication whether a cell contains combined content\n   *              read:   `isCombined = content & Content.isCombined;`\n   *              set:    `content |= Content.isCombined;`\n   *              clear:  `content &= ~Content.isCombined;`\n   */\n  IS_COMBINED_MASK = 0x200000,  // 1 << 21\n\n  /**\n   * bit 1..22    mask to check whether a cell contains any string data\n   *              we need to check for codepoint and isCombined bits to see\n   *              whether a cell contains anything\n   *              read:   `isEmpty = !(content & Content.hasContent)`\n   */\n  HAS_CONTENT_MASK = 0x3FFFFF,\n\n  /**\n   * bit 23..24   wcwidth value of cell, takes 2 bits (ranges from 0..2)\n   *              read:   `width = (content & Content.widthMask) >> Content.widthShift;`\n   *                      `hasWidth = content & Content.widthMask;`\n   *                      as long as wcwidth is highest value in `content`:\n   *                      `width = content >> Content.widthShift;`\n   *              write:  `content |= (width << Content.widthShift) & Content.widthMask;`\n   *                      shortcut if precondition `0 <= width <= 3` is met:\n   *                      `content |= width << Content.widthShift;`\n   */\n  WIDTH_MASK = 0xC00000,   // 3 << 22\n  WIDTH_SHIFT = 22\n}\n\nexport const enum Attributes {\n  /**\n   * bit 1..8     blue in RGB, color in P256 and P16\n   */\n  BLUE_MASK = 0xFF,\n  BLUE_SHIFT = 0,\n  PCOLOR_MASK = 0xFF,\n  PCOLOR_SHIFT = 0,\n\n  /**\n   * bit 9..16    green in RGB\n   */\n  GREEN_MASK = 0xFF00,\n  GREEN_SHIFT = 8,\n\n  /**\n   * bit 17..24   red in RGB\n   */\n  RED_MASK = 0xFF0000,\n  RED_SHIFT = 16,\n\n  /**\n   * bit 25..26   color mode: DEFAULT (0) | P16 (1) | P256 (2) | RGB (3)\n   */\n  CM_MASK = 0x3000000,\n  CM_DEFAULT = 0,\n  CM_P16 = 0x1000000,\n  CM_P256 = 0x2000000,\n  CM_RGB = 0x3000000,\n\n  /**\n   * bit 1..24  RGB room\n   */\n  RGB_MASK = 0xFFFFFF\n}\n\nexport const enum FgFlags {\n  /**\n   * bit 27..31 (32th bit unused)\n   */\n  INVERSE = 0x4000000,\n  BOLD = 0x8000000,\n  UNDERLINE = 0x10000000,\n  BLINK = 0x20000000,\n  INVISIBLE = 0x40000000\n}\n\nexport const enum BgFlags {\n  /**\n   * bit 27..32 (upper 4 unused)\n   */\n  ITALIC = 0x4000000,\n  DIM = 0x8000000\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * A matrix that when multiplies will translate 0-1 coordinates (left to right,\n * top to bottom) to clip space.\n */\nexport const PROJECTION_MATRIX = new Float32Array([\n  2, 0, 0, 0,\n  0, -2, 0, 0,\n  0, 0, 1, 0,\n  -1, 1, 0, 1\n]);\n\nexport function createProgram(gl: WebGLRenderingContext, vertexSource: string, fragmentSource: string): WebGLProgram | undefined {\n  const program = throwIfFalsy(gl.createProgram());\n  gl.attachShader(program, throwIfFalsy(createShader(gl, gl.VERTEX_SHADER, vertexSource)));\n  gl.attachShader(program, throwIfFalsy(createShader(gl, gl.FRAGMENT_SHADER, fragmentSource)));\n  gl.linkProgram(program);\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (success) {\n    return program;\n  }\n\n  console.error(gl.getProgramInfoLog(program));\n  gl.deleteProgram(program);\n}\n\nexport function createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader | undefined {\n  const shader = throwIfFalsy(gl.createShader(type));\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (success) {\n    return shader;\n  }\n\n  console.error(gl.getShaderInfoLog(shader));\n  gl.deleteShader(shader);\n}\n\nexport function expandFloat32Array(source: Float32Array, max: number): Float32Array {\n  const newLength = Math.min(source.length * 2, max);\n  const newArray = new Float32Array(newLength);\n  for (let i = 0; i < source.length; i++) {\n    newArray[i] = source[i];\n  }\n  return newArray;\n}\n\nexport function throwIfFalsy<T>(value: T | undefined | null): T {\n  if (!value) {\n    throw new Error('value must not be falsy');\n  }\n  return value;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ICharAtlasConfig } from './Types';\nimport { DEFAULT_COLOR } from 'common/buffer/Constants';\nimport { Terminal, FontWeight } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\n\nconst NULL_COLOR: IColor = {\n  css: '',\n  rgba: 0\n};\n\nexport function generateConfig(scaledCharWidth: number, scaledCharHeight: number, terminal: Terminal, colors: IColorSet): ICharAtlasConfig {\n  // null out some fields that don't matter\n  const clonedColors: IColorSet = {\n    foreground: colors.foreground,\n    background: colors.background,\n    cursor: NULL_COLOR,\n    cursorAccent: NULL_COLOR,\n    selection: NULL_COLOR,\n    // For the static char atlas, we only use the first 16 colors, but we need all 256 for the\n    // dynamic character atlas.\n    ansi: colors.ansi.slice()\n  };\n  return {\n    devicePixelRatio: window.devicePixelRatio,\n    scaledCharWidth,\n    scaledCharHeight,\n    fontFamily: terminal.getOption('fontFamily'),\n    fontSize: terminal.getOption('fontSize'),\n    fontWeight: terminal.getOption('fontWeight') as FontWeight,\n    fontWeightBold: terminal.getOption('fontWeightBold') as FontWeight,\n    allowTransparency: terminal.getOption('allowTransparency'),\n    colors: clonedColors\n  };\n}\n\nexport function configEquals(a: ICharAtlasConfig, b: ICharAtlasConfig): boolean {\n  for (let i = 0; i < a.colors.ansi.length; i++) {\n    if (a.colors.ansi[i].rgba !== b.colors.ansi[i].rgba) {\n      return false;\n    }\n  }\n  return a.devicePixelRatio === b.devicePixelRatio &&\n      a.fontFamily === b.fontFamily &&\n      a.fontSize === b.fontSize &&\n      a.fontWeight === b.fontWeight &&\n      a.fontWeightBold === b.fontWeightBold &&\n      a.allowTransparency === b.allowTransparency &&\n      a.scaledCharWidth === b.scaledCharWidth &&\n      a.scaledCharHeight === b.scaledCharHeight &&\n      a.colors.foreground === b.colors.foreground &&\n      a.colors.background === b.colors.background;\n}\n\nexport function is256Color(colorCode: number): boolean {\n  return colorCode < DEFAULT_COLOR;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const INVERTED_DEFAULT_COLOR = 257;\nexport const DIM_OPACITY = 0.5;\n\nexport const CHAR_ATLAS_CELL_SPACING = 1;\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport type TypedArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray\n  | Int8Array | Int16Array | Int32Array\n  | Float32Array | Float64Array;\n\n\n/**\n * polyfill for TypedArray.fill\n * This is needed to support .fill in all safari versions and IE 11.\n */\nexport function fill<T extends TypedArray>(array: T, value: number, start?: number, end?: number): T {\n  // all modern engines that support .fill\n  if (array.fill) {\n    return array.fill(value, start, end) as T;\n  }\n  return fillFallback(array, value, start, end);\n}\n\nexport function fillFallback<T extends TypedArray>(array: T, value: number, start: number = 0, end: number = array.length): T {\n  // safari and IE 11\n  // since IE 11 does not support Array.prototype.fill either\n  // we cannot use the suggested polyfill from MDN\n  // instead we simply fall back to looping\n  if (start >= array.length) {\n    return array;\n  }\n  start = (array.length + start) % array.length;\n  if (end >= array.length) {\n    end = array.length;\n  } else {\n    end = (array.length + end) % array.length;\n  }\n  for (let i = start; i < end; ++i) {\n    array[i] = value;\n  }\n  return array;\n}\n\n/**\n * Concat two typed arrays `a` and `b`.\n * Returns a new typed array.\n */\nexport function concat<T extends TypedArray>(a: T, b: T): T {\n  const result = new (a.constructor as any)(a.length + b.length);\n  result.set(a);\n  result.set(b, a.length);\n  return result;\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ITerminal } from '../../../src/Types';\nimport { GlyphRenderer } from './GlyphRenderer';\nimport { LinkRenderLayer } from './renderLayer/LinkRenderLayer';\nimport { CursorRenderLayer } from './renderLayer/CursorRenderLayer';\nimport { acquireCharAtlas } from './atlas/CharAtlasCache';\nimport { WebglCharAtlas } from './atlas/WebglCharAtlas';\nimport { RectangleRenderer } from './RectangleRenderer';\nimport { IWebGL2RenderingContext } from './Types';\nimport { INVERTED_DEFAULT_COLOR } from 'browser/renderer/atlas/Constants';\nimport { RenderModel, COMBINED_CHAR_BIT_MASK } from './RenderModel';\nimport { Disposable } from 'common/Lifecycle';\nimport { DEFAULT_COLOR, CHAR_DATA_CHAR_INDEX, CHAR_DATA_CODE_INDEX, NULL_CELL_CODE } from 'common/buffer/Constants';\nimport { Terminal } from 'xterm';\nimport { getLuminance } from './ColorUtils';\nimport { IRenderLayer } from './renderLayer/Types';\nimport { IRenderDimensions, IRenderer } from 'browser/renderer/Types';\nimport { IColorSet } from 'browser/Types';\nimport { FLAGS } from './Constants';\nimport { getCompatAttr } from './CharDataCompat';\n\nexport const INDICIES_PER_CELL = 4;\n\nexport class WebglRenderer extends Disposable implements IRenderer {\n  private _renderLayers: IRenderLayer[];\n  private _charAtlas: WebglCharAtlas | undefined;\n  private _devicePixelRatio: number;\n\n  private _model: RenderModel = new RenderModel();\n\n  private _canvas: HTMLCanvasElement;\n  private _gl: IWebGL2RenderingContext;\n  private _rectangleRenderer: RectangleRenderer;\n  private _glyphRenderer: GlyphRenderer;\n\n  public dimensions: IRenderDimensions;\n\n  private _core: ITerminal;\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    preserveDrawingBuffer?: boolean\n  ) {\n    super();\n\n    this._core = (<any>this._terminal)._core;\n\n    this._applyBgLuminanceBasedSelection();\n\n    this._renderLayers = [\n      new LinkRenderLayer(this._core.screenElement, 2, this._colors, this._core),\n      new CursorRenderLayer(this._core.screenElement, 3, this._colors)\n    ];\n    this.dimensions = {\n      scaledCharWidth: 0,\n      scaledCharHeight: 0,\n      scaledCellWidth: 0,\n      scaledCellHeight: 0,\n      scaledCharLeft: 0,\n      scaledCharTop: 0,\n      scaledCanvasWidth: 0,\n      scaledCanvasHeight: 0,\n      canvasWidth: 0,\n      canvasHeight: 0,\n      actualCellWidth: 0,\n      actualCellHeight: 0\n    };\n    this._devicePixelRatio = window.devicePixelRatio;\n    this._updateDimensions();\n\n    this._canvas = document.createElement('canvas');\n\n    const contextAttributes = {\n      antialias: false,\n      depth: false,\n      preserveDrawingBuffer\n    };\n    this._gl = this._canvas.getContext('webgl2', contextAttributes) as IWebGL2RenderingContext;\n    if (!this._gl) {\n        throw new Error('WebGL2 not supported');\n    }\n    this._core.screenElement.appendChild(this._canvas);\n\n    this._rectangleRenderer = new RectangleRenderer(this._terminal, this._colors, this._gl, this.dimensions);\n    this._glyphRenderer = new GlyphRenderer(this._terminal, this._colors, this._gl, this.dimensions);\n\n    // Update dimensions and acquire char atlas\n    this.onCharSizeChanged();\n  }\n\n  public dispose(): void {\n    this._renderLayers.forEach(l => l.dispose());\n    this._core.screenElement.removeChild(this._canvas);\n    super.dispose();\n  }\n\n  private _applyBgLuminanceBasedSelection(): void {\n    // HACK: This is needed until webgl renderer adds support for selection colors\n    if (getLuminance(this._colors.background) > 0.5) {\n      this._colors.selection = { css: '#000', rgba: 255 };\n    } else {\n      this._colors.selection = { css: '#fff', rgba: 4294967295 };\n    }\n  }\n\n  public setColors(colors: IColorSet): void {\n    this._colors = colors;\n\n    this._applyBgLuminanceBasedSelection();\n\n    // Clear layers and force a full render\n    this._renderLayers.forEach(l => {\n      l.setColors(this._terminal, this._colors);\n      l.reset(this._terminal);\n    });\n\n    this._rectangleRenderer.setColors();\n    this._glyphRenderer.setColors();\n\n    this._refreshCharAtlas();\n\n    // Force a full refresh\n    this._model.clear();\n  }\n\n  public onDevicePixelRatioChange(): void {\n    // If the device pixel ratio changed, the char atlas needs to be regenerated\n    // and the terminal needs to refreshed\n    if (this._devicePixelRatio !== window.devicePixelRatio) {\n      this._devicePixelRatio = window.devicePixelRatio;\n      this.onResize(this._terminal.cols, this._terminal.rows);\n    }\n  }\n\n  public onResize(cols: number, rows: number): void {\n    // Update character and canvas dimensions\n    this._updateDimensions();\n\n    this._model.resize(this._terminal.cols, this._terminal.rows);\n    this._rectangleRenderer.onResize();\n\n    // Resize all render layers\n    this._renderLayers.forEach(l => l.resize(this._terminal, this.dimensions));\n\n    // Resize the canvas\n    this._canvas.width = this.dimensions.scaledCanvasWidth;\n    this._canvas.height = this.dimensions.scaledCanvasHeight;\n    this._canvas.style.width = `${this.dimensions.canvasWidth}px`;\n    this._canvas.style.height = `${this.dimensions.canvasHeight}px`;\n\n    // Resize the screen\n    this._core.screenElement.style.width = `${this.dimensions.canvasWidth}px`;\n    this._core.screenElement.style.height = `${this.dimensions.canvasHeight}px`;\n    this._glyphRenderer.setDimensions(this.dimensions);\n    this._glyphRenderer.onResize();\n\n    this._refreshCharAtlas();\n\n    // Force a full refresh\n    this._model.clear();\n  }\n\n  public onCharSizeChanged(): void {\n    this.onResize(this._terminal.cols, this._terminal.rows);\n  }\n\n  public onBlur(): void {\n    this._renderLayers.forEach(l => l.onBlur(this._terminal));\n  }\n\n  public onFocus(): void {\n    this._renderLayers.forEach(l => l.onFocus(this._terminal));\n  }\n\n  public onSelectionChanged(start: [number, number], end: [number, number], columnSelectMode: boolean): void {\n    this._renderLayers.forEach(l => l.onSelectionChanged(this._terminal, start, end, columnSelectMode));\n\n    this._updateSelectionModel(start, end);\n\n    this._rectangleRenderer.updateSelection(this._model.selection, columnSelectMode);\n    this._glyphRenderer.updateSelection(this._model, columnSelectMode);\n\n    // TODO: #2102 Should this move to RenderCoordinator?\n    this._core.refresh(0, this._terminal.rows - 1);\n  }\n\n  public onCursorMove(): void {\n    this._renderLayers.forEach(l => l.onCursorMove(this._terminal));\n  }\n\n  public onOptionsChanged(): void {\n    this._renderLayers.forEach(l => l.onOptionsChanged(this._terminal));\n    this._updateDimensions();\n    this._refreshCharAtlas();\n  }\n\n  /**\n   * Refreshes the char atlas, aquiring a new one if necessary.\n   * @param terminal The terminal.\n   * @param colorSet The color set to use for the char atlas.\n   */\n  private _refreshCharAtlas(): void {\n    if (this.dimensions.scaledCharWidth <= 0 && this.dimensions.scaledCharHeight <= 0) {\n      return;\n    }\n\n    const atlas = acquireCharAtlas(this._terminal, this._colors, this.dimensions.scaledCharWidth, this.dimensions.scaledCharHeight);\n    if (!('getRasterizedGlyph' in atlas)) {\n      throw new Error('The webgl renderer only works with the webgl char atlas');\n    }\n    this._charAtlas = atlas as WebglCharAtlas;\n    this._charAtlas.warmUp();\n    this._glyphRenderer.setAtlas(this._charAtlas);\n  }\n\n  public clear(): void {\n    this._renderLayers.forEach(l => l.reset(this._terminal));\n  }\n\n  public registerCharacterJoiner(handler: (text: string) => [number, number][]): number {\n    return -1;\n  }\n\n  public deregisterCharacterJoiner(joinerId: number): boolean {\n    return false;\n  }\n\n  public renderRows(start: number, end: number): void {\n    // Update render layers\n    this._renderLayers.forEach(l => l.onGridChanged(this._terminal, start, end));\n\n    // Tell renderer the frame is beginning\n    if (this._glyphRenderer.beginFrame()) {\n      this._model.clear();\n    }\n\n    // Update model to reflect what's drawn\n    this._updateModel(start, end);\n\n    // Render\n    this._rectangleRenderer.render();\n    this._glyphRenderer.render(this._model, this._model.selection.hasSelection);\n  }\n\n  private _updateModel(start: number, end: number): void {\n    const terminal = this._core;\n\n    for (let y = start; y <= end; y++) {\n      const row = y + terminal.buffer.ydisp;\n      const line = terminal.buffer.lines.get(row)!;\n      this._model.lineLengths[y] = 0;\n      for (let x = 0; x < terminal.cols; x++) {\n        const charData = line.get(x);\n        const chars = charData[CHAR_DATA_CHAR_INDEX];\n        let code = charData[CHAR_DATA_CODE_INDEX];\n        const attr = getCompatAttr(line, x); // charData[CHAR_DATA_ATTR_INDEX];\n        const i = ((y * terminal.cols) + x) * INDICIES_PER_CELL;\n\n        if (code !== NULL_CELL_CODE) {\n          this._model.lineLengths[y] = x + 1;\n        }\n\n        // Nothing has changed, no updates needed\n        if (this._model.cells[i] === code && this._model.cells[i + 1] === attr) {\n          continue;\n        }\n\n        // Resolve bg and fg and cache in the model\n        const flags = attr >> 18;\n        let bg = attr & 0x1ff;\n        let fg = (attr >> 9) & 0x1ff;\n\n        // If inverse flag is on, the foreground should become the background.\n        if (flags & FLAGS.INVERSE) {\n          const temp = bg;\n          bg = fg;\n          fg = temp;\n          if (fg === DEFAULT_COLOR) {\n            fg = INVERTED_DEFAULT_COLOR;\n          }\n          if (bg === DEFAULT_COLOR) {\n            bg = INVERTED_DEFAULT_COLOR;\n          }\n        }\n        const drawInBrightColor = terminal.options.drawBoldTextInBrightColors && !!(flags & FLAGS.BOLD) && fg < 8 && fg !== INVERTED_DEFAULT_COLOR;\n        fg += drawInBrightColor ? 8 : 0;\n\n        // Flag combined chars with a bit mask so they're easily identifiable\n        if (chars.length > 1) {\n          code = code | COMBINED_CHAR_BIT_MASK;\n        }\n\n        this._model.cells[i    ] = code;\n        this._model.cells[i + 1] = attr;\n        this._model.cells[i + 2] = bg;\n        this._model.cells[i + 3] = fg;\n\n        this._glyphRenderer.updateCell(x, y, code, attr, bg, fg, chars);\n      }\n    }\n    this._rectangleRenderer.updateBackgrounds(this._model);\n  }\n\n  private _updateSelectionModel(start: [number, number], end: [number, number]): void {\n    const terminal = this._terminal;\n\n    // Selection does not exist\n    if (!start || !end || (start[0] === end[0] && start[1] === end[1])) {\n      this._model.clearSelection();\n      return;\n    }\n\n    // Translate from buffer position to viewport position\n    const viewportStartRow = start[1] - terminal.buffer.viewportY;\n    const viewportEndRow = end[1] - terminal.buffer.viewportY;\n    const viewportCappedStartRow = Math.max(viewportStartRow, 0);\n    const viewportCappedEndRow = Math.min(viewportEndRow, terminal.rows - 1);\n\n    // No need to draw the selection\n    if (viewportCappedStartRow >= terminal.rows || viewportCappedEndRow < 0) {\n      this._model.clearSelection();\n      return;\n    }\n\n    this._model.selection.hasSelection = true;\n    this._model.selection.viewportStartRow = viewportStartRow;\n    this._model.selection.viewportEndRow = viewportEndRow;\n    this._model.selection.viewportCappedStartRow = viewportCappedStartRow;\n    this._model.selection.viewportCappedEndRow = viewportCappedEndRow;\n    this._model.selection.startCol = start[0];\n    this._model.selection.endCol = end[0];\n  }\n\n  /**\n   * Recalculates the character and canvas dimensions.\n   */\n  private _updateDimensions(): void {\n    // TODO: Acquire CharSizeService properly\n\n    // Perform a new measure if the CharMeasure dimensions are not yet available\n    if (!(<any>this._core)._charSizeService.width || !(<any>this._core)._charSizeService.height) {\n      return;\n    }\n\n    // Calculate the scaled character width. Width is floored as it must be\n    // drawn to an integer grid in order for the CharAtlas \"stamps\" to not be\n    // blurry. When text is drawn to the grid not using the CharAtlas, it is\n    // clipped to ensure there is no overlap with the next cell.\n\n    // NOTE: ceil fixes sometime, floor does others :s\n\n    this.dimensions.scaledCharWidth = Math.floor((<any>this._core)._charSizeService.width * this._devicePixelRatio);\n\n    // Calculate the scaled character height. Height is ceiled in case\n    // devicePixelRatio is a floating point number in order to ensure there is\n    // enough space to draw the character to the cell.\n    this.dimensions.scaledCharHeight = Math.ceil((<any>this._core)._charSizeService.height * this._devicePixelRatio);\n\n    // Calculate the scaled cell height, if lineHeight is not 1 then the value\n    // will be floored because since lineHeight can never be lower then 1, there\n    // is a guarentee that the scaled line height will always be larger than\n    // scaled char height.\n    this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.getOption('lineHeight'));\n\n    // Calculate the y coordinate within a cell that text should draw from in\n    // order to draw in the center of a cell.\n    this.dimensions.scaledCharTop = this._terminal.getOption('lineHeight') === 1 ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2);\n\n    // Calculate the scaled cell width, taking the letterSpacing into account.\n    this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.getOption('letterSpacing'));\n\n    // Calculate the x coordinate with a cell that text should draw from in\n    // order to draw in the center of a cell.\n    this.dimensions.scaledCharLeft = Math.floor(this._terminal.getOption('letterSpacing') / 2);\n\n    // Recalculate the canvas dimensions; scaled* define the actual number of\n    // pixel in the canvas\n    this.dimensions.scaledCanvasHeight = this._terminal.rows * this.dimensions.scaledCellHeight;\n    this.dimensions.scaledCanvasWidth = this._terminal.cols * this.dimensions.scaledCellWidth;\n\n    // The the size of the canvas on the page. It's very important that this\n    // rounds to nearest integer and not ceils as browsers often set\n    // window.devicePixelRatio as something like 1.100000023841858, when it's\n    // actually 1.1. Ceiling causes blurriness as the backing canvas image is 1\n    // pixel too large for the canvas element size.\n    this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / this._devicePixelRatio);\n    this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / this._devicePixelRatio);\n\n    // this.dimensions.scaledCanvasHeight = this.dimensions.canvasHeight * devicePixelRatio;\n    // this.dimensions.scaledCanvasWidth = this.dimensions.canvasWidth * devicePixelRatio;\n\n    // Get the _actual_ dimensions of an individual cell. This needs to be\n    // derived from the canvasWidth/Height calculated above which takes into\n    // account window.devicePixelRatio. CharMeasure.width/height by itself is\n    // insufficient when the page is not at 100% zoom level as CharMeasure is\n    // measured in CSS pixels, but the actual char size on the canvas can\n    // differ.\n    // this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;\n    // this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;\n\n    // This fixes 110% and 125%, not 150% or 175% though\n    this.dimensions.actualCellHeight = this.dimensions.scaledCellHeight / this._devicePixelRatio;\n    this.dimensions.actualCellWidth = this.dimensions.scaledCellWidth / this._devicePixelRatio;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderModel, ISelectionRenderModel } from './Types';\nimport { fill } from 'common/TypedArrayUtils';\n\nexport const RENDER_MODEL_INDICIES_PER_CELL = 4;\n\nexport const COMBINED_CHAR_BIT_MASK = 0x80000000;\n\nexport class RenderModel implements IRenderModel {\n  public cells: Uint32Array;\n  public lineLengths: Uint32Array;\n  public selection: ISelectionRenderModel;\n\n  constructor() {\n    this.cells = new Uint32Array(0);\n    this.lineLengths = new Uint32Array(0);\n    this.selection = {\n      hasSelection: false,\n      viewportStartRow: 0,\n      viewportEndRow: 0,\n      viewportCappedStartRow: 0,\n      viewportCappedEndRow: 0,\n      startCol: 0,\n      endCol: 0\n    };\n  }\n\n  public resize(cols: number, rows: number): void {\n    const indexCount = cols * rows * RENDER_MODEL_INDICIES_PER_CELL;\n    if (indexCount !== this.cells.length) {\n      this.cells = new Uint32Array(indexCount);\n      this.lineLengths = new Uint32Array(rows);\n    }\n  }\n\n  public clear(): void {\n    fill(this.cells, 0, 0);\n    fill(this.lineLengths, 0, 0);\n    this.clearSelection();\n  }\n\n  public clearSelection(): void {\n    this.selection.hasSelection = false;\n    this.selection.viewportStartRow = 0;\n    this.selection.viewportEndRow = 0;\n    this.selection.viewportCappedStartRow = 0;\n    this.selection.viewportCappedEndRow = 0;\n    this.selection.startCol = 0;\n    this.selection.endCol = 0;\n  }\n}\n","/**\n * @license MIT\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n */\n\nimport { IColor } from 'browser/Types';\n\nexport function getLuminance(color: IColor): number {\n  // Coefficients taken from: https://www.w3.org/TR/AERT/#color-contrast\n  const r = color.rgba >> 24 & 0xff;\n  const g = color.rgba >> 16 & 0xff;\n  const b = color.rgba >> 8 & 0xff;\n  return (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderLayer } from './Types';\nimport { IGlyphIdentifier } from '../atlas/Types';\nimport { acquireCharAtlas } from '../atlas/CharAtlasCache';\nimport { Terminal } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { CellData } from 'common/buffer/CellData';\nimport { WebglCharAtlas } from 'atlas/WebglCharAtlas';\nimport { throwIfFalsy } from '../WebglUtils';\n\nexport abstract class BaseRenderLayer implements IRenderLayer {\n  private _canvas: HTMLCanvasElement;\n  protected _ctx!: CanvasRenderingContext2D;\n  private _scaledCharWidth: number = 0;\n  private _scaledCharHeight: number = 0;\n  private _scaledCellWidth: number = 0;\n  private _scaledCellHeight: number = 0;\n  private _scaledCharLeft: number = 0;\n  private _scaledCharTop: number = 0;\n\n  protected _charAtlas: WebglCharAtlas | undefined;\n\n  /**\n   * An object that's reused when drawing glyphs in order to reduce GC.\n   */\n  private _currentGlyphIdentifier: IGlyphIdentifier = {\n    chars: '',\n    code: 0,\n    bg: 0,\n    fg: 0,\n    bold: false,\n    dim: false,\n    italic: false\n  };\n\n  constructor(\n    private _container: HTMLElement,\n    id: string,\n    zIndex: number,\n    private _alpha: boolean,\n    protected _colors: IColorSet\n  ) {\n    this._canvas = document.createElement('canvas');\n    this._canvas.classList.add(`xterm-${id}-layer`);\n    this._canvas.style.zIndex = zIndex.toString();\n    this._initCanvas();\n    this._container.appendChild(this._canvas);\n  }\n\n  public dispose(): void {\n    this._container.removeChild(this._canvas);\n    if (this._charAtlas) {\n      this._charAtlas.dispose();\n    }\n  }\n\n  private _initCanvas(): void {\n    this._ctx = throwIfFalsy(this._canvas.getContext('2d', {alpha: this._alpha}));\n    // Draw the background if this is an opaque layer\n    if (!this._alpha) {\n      this._clearAll();\n    }\n  }\n\n  public onOptionsChanged(terminal: Terminal): void {}\n  public onBlur(terminal: Terminal): void {}\n  public onFocus(terminal: Terminal): void {}\n  public onCursorMove(terminal: Terminal): void {}\n  public onGridChanged(terminal: Terminal, startRow: number, endRow: number): void {}\n  public onSelectionChanged(terminal: Terminal, start: [number, number], end: [number, number], columnSelectMode: boolean = false): void {}\n\n  public setColors(terminal: Terminal, colorSet: IColorSet): void {\n    this._refreshCharAtlas(terminal, colorSet);\n  }\n\n  protected _setTransparency(terminal: Terminal, alpha: boolean): void {\n    // Do nothing when alpha doesn't change\n    if (alpha === this._alpha) {\n      return;\n    }\n\n    // Create new canvas and replace old one\n    const oldCanvas = this._canvas;\n    this._alpha = alpha;\n    // Cloning preserves properties\n    this._canvas = <HTMLCanvasElement>this._canvas.cloneNode();\n    this._initCanvas();\n    this._container.replaceChild(this._canvas, oldCanvas);\n\n    // Regenerate char atlas and force a full redraw\n    this._refreshCharAtlas(terminal, this._colors);\n    this.onGridChanged(terminal, 0, terminal.rows - 1);\n  }\n\n  /**\n   * Refreshes the char atlas, aquiring a new one if necessary.\n   * @param terminal The terminal.\n   * @param colorSet The color set to use for the char atlas.\n   */\n  private _refreshCharAtlas(terminal: Terminal, colorSet: IColorSet): void {\n    if (this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0) {\n      return;\n    }\n    this._charAtlas = acquireCharAtlas(terminal, colorSet, this._scaledCharWidth, this._scaledCharHeight);\n    this._charAtlas.warmUp();\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    this._scaledCellWidth = dim.scaledCellWidth;\n    this._scaledCellHeight = dim.scaledCellHeight;\n    this._scaledCharWidth = dim.scaledCharWidth;\n    this._scaledCharHeight = dim.scaledCharHeight;\n    this._scaledCharLeft = dim.scaledCharLeft;\n    this._scaledCharTop = dim.scaledCharTop;\n    this._canvas.width = dim.scaledCanvasWidth;\n    this._canvas.height = dim.scaledCanvasHeight;\n    this._canvas.style.width = `${dim.canvasWidth}px`;\n    this._canvas.style.height = `${dim.canvasHeight}px`;\n\n    // Draw the background if this is an opaque layer\n    if (!this._alpha) {\n      this._clearAll();\n    }\n\n    this._refreshCharAtlas(terminal, this._colors);\n  }\n\n  public abstract reset(terminal: Terminal): void;\n\n  /**\n   * Fills 1+ cells completely. This uses the existing fillStyle on the context.\n   * @param x The column to start at.\n   * @param y The row to start at\n   * @param width The number of columns to fill.\n   * @param height The number of rows to fill.\n   */\n  protected _fillCells(x: number, y: number, width: number, height: number): void {\n    this._ctx.fillRect(\n        x * this._scaledCellWidth,\n        y * this._scaledCellHeight,\n        width * this._scaledCellWidth,\n        height * this._scaledCellHeight);\n  }\n\n  /**\n   * Fills a 1px line (2px on HDPI) at the bottom of the cell. This uses the\n   * existing fillStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _fillBottomLineAtCells(x: number, y: number, width: number = 1): void {\n    this._ctx.fillRect(\n        x * this._scaledCellWidth,\n        (y + 1) * this._scaledCellHeight - window.devicePixelRatio - 1 /* Ensure it's drawn within the cell */,\n        width * this._scaledCellWidth,\n        window.devicePixelRatio);\n  }\n\n  /**\n   * Fills a 1px line (2px on HDPI) at the left of the cell. This uses the\n   * existing fillStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _fillLeftLineAtCell(x: number, y: number): void {\n    this._ctx.fillRect(\n        x * this._scaledCellWidth,\n        y * this._scaledCellHeight,\n        window.devicePixelRatio,\n        this._scaledCellHeight);\n  }\n\n  /**\n   * Strokes a 1px rectangle (2px on HDPI) around a cell. This uses the existing\n   * strokeStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _strokeRectAtCell(x: number, y: number, width: number, height: number): void {\n    this._ctx.lineWidth = window.devicePixelRatio;\n    this._ctx.strokeRect(\n        x * this._scaledCellWidth + window.devicePixelRatio / 2,\n        y * this._scaledCellHeight + (window.devicePixelRatio / 2),\n        width * this._scaledCellWidth - window.devicePixelRatio,\n        (height * this._scaledCellHeight) - window.devicePixelRatio);\n  }\n\n  /**\n   * Clears the entire canvas.\n   */\n  protected _clearAll(): void {\n    if (this._alpha) {\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n    } else {\n      this._ctx.fillStyle = this._colors.background.css;\n      this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n    }\n  }\n\n  /**\n   * Clears 1+ cells completely.\n   * @param x The column to start at.\n   * @param y The row to start at.\n   * @param width The number of columns to clear.\n   * @param height The number of rows to clear.\n   */\n  protected _clearCells(x: number, y: number, width: number, height: number): void {\n    if (this._alpha) {\n      this._ctx.clearRect(\n          x * this._scaledCellWidth,\n          y * this._scaledCellHeight,\n          width * this._scaledCellWidth,\n          height * this._scaledCellHeight);\n    } else {\n      this._ctx.fillStyle = this._colors.background.css;\n      this._ctx.fillRect(\n          x * this._scaledCellWidth,\n          y * this._scaledCellHeight,\n          width * this._scaledCellWidth,\n          height * this._scaledCellHeight);\n    }\n  }\n\n  /**\n   * Draws a truecolor character at the cell. The character will be clipped to\n   * ensure that it fits with the cell, including the cell to the right if it's\n   * a wide character. This uses the existing fillStyle on the context.\n   * @param terminal The terminal.\n   * @param cell The cell data for the character to draw.\n   * @param x The column to draw at.\n   * @param y The row to draw at.\n   * @param color The color of the character.\n   */\n  protected _fillCharTrueColor(terminal: Terminal, cell: CellData, x: number, y: number): void {\n    this._ctx.font = this._getFont(terminal, false, false);\n    this._ctx.textBaseline = 'middle';\n    this._clipRow(terminal, y);\n    this._ctx.fillText(\n        cell.getChars(),\n        x * this._scaledCellWidth + this._scaledCharLeft,\n        y * this._scaledCellHeight + this._scaledCharTop + this._scaledCharHeight / 2);\n  }\n\n  /**\n   * Clips a row to ensure no pixels will be drawn outside the cells in the row.\n   * @param terminal The terminal.\n   * @param y The row to clip.\n   */\n  private _clipRow(terminal: Terminal, y: number): void {\n    this._ctx.beginPath();\n    this._ctx.rect(\n        0,\n        y * this._scaledCellHeight,\n        terminal.cols * this._scaledCellWidth,\n        this._scaledCellHeight);\n    this._ctx.clip();\n  }\n\n  /**\n   * Gets the current font.\n   * @param terminal The terminal.\n   * @param isBold If we should use the bold fontWeight.\n   */\n  protected _getFont(terminal: Terminal, isBold: boolean, isItalic: boolean): string {\n    const fontWeight = isBold ? terminal.getOption('fontWeightBold') : terminal.getOption('fontWeight');\n    const fontStyle = isItalic ? 'italic' : '';\n\n    return `${fontStyle} ${fontWeight} ${terminal.getOption('fontSize') * window.devicePixelRatio}px ${terminal.getOption('fontFamily')}`;\n  }\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { generateConfig, configEquals } from './CharAtlasUtils';\nimport { WebglCharAtlas } from './WebglCharAtlas';\nimport { ICharAtlasConfig } from './Types';\nimport { Terminal } from 'xterm';\nimport { IColorSet } from 'browser/Types';\n\ninterface ICharAtlasCacheEntry {\n  atlas: WebglCharAtlas;\n  config: ICharAtlasConfig;\n  // N.B. This implementation potentially holds onto copies of the terminal forever, so\n  // this may cause memory leaks.\n  ownedBy: Terminal[];\n}\n\nconst charAtlasCache: ICharAtlasCacheEntry[] = [];\n\n/**\n * Acquires a char atlas, either generating a new one or returning an existing\n * one that is in use by another terminal.\n * @param terminal The terminal.\n * @param colors The colors to use.\n */\nexport function acquireCharAtlas(\n  terminal: Terminal,\n  colors: IColorSet,\n  scaledCharWidth: number,\n  scaledCharHeight: number\n): WebglCharAtlas {\n  const newConfig = generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors);\n\n  // Check to see if the terminal already owns this config\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const entry = charAtlasCache[i];\n    const ownedByIndex = entry.ownedBy.indexOf(terminal);\n    if (ownedByIndex >= 0) {\n      if (configEquals(entry.config, newConfig)) {\n        return entry.atlas;\n      }\n      // The configs differ, release the terminal from the entry\n      if (entry.ownedBy.length === 1) {\n        entry.atlas.dispose();\n        charAtlasCache.splice(i, 1);\n      } else {\n        entry.ownedBy.splice(ownedByIndex, 1);\n      }\n      break;\n    }\n  }\n\n  // Try match a char atlas from the cache\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const entry = charAtlasCache[i];\n    if (configEquals(entry.config, newConfig)) {\n      // Add the terminal to the cache entry and return\n      entry.ownedBy.push(terminal);\n      return entry.atlas;\n    }\n  }\n\n  const newEntry: ICharAtlasCacheEntry = {\n    atlas: new WebglCharAtlas(document, newConfig),\n    config: newConfig,\n    ownedBy: [terminal]\n  };\n  charAtlasCache.push(newEntry);\n  return newEntry.atlas;\n}\n\n/**\n * Removes a terminal reference from the cache, allowing its memory to be freed.\n * @param terminal The terminal to remove.\n */\nexport function removeTerminalFromCache(terminal: Terminal): void {\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const index = charAtlasCache[i].ownedBy.indexOf(terminal);\n    if (index !== -1) {\n      if (charAtlasCache[i].ownedBy.length === 1) {\n        // Remove the cache entry if it's the only terminal\n        charAtlasCache[i].atlas.dispose();\n        charAtlasCache.splice(i, 1);\n      } else {\n        // Remove the reference from the cache entry\n        charAtlasCache[i].ownedBy.splice(index, 1);\n      }\n      break;\n    }\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { CharData, ICellData } from 'common/Types';\nimport { stringFromCodePoint } from 'common/input/TextDecoder';\nimport { CHAR_DATA_CHAR_INDEX, CHAR_DATA_WIDTH_INDEX, CHAR_DATA_ATTR_INDEX, Content } from 'common/buffer/Constants';\nimport { AttributeData } from 'common/buffer/AttributeData';\n\n/**\n * CellData - represents a single Cell in the terminal buffer.\n */\nexport class CellData extends AttributeData implements ICellData {\n  /** Helper to create CellData from CharData. */\n  public static fromCharData(value: CharData): CellData {\n    const obj = new CellData();\n    obj.setFromCharData(value);\n    return obj;\n  }\n  /** Primitives from terminal buffer. */\n  public content: number = 0;\n  public fg: number = 0;\n  public bg: number = 0;\n  public combinedData: string = '';\n  /** Whether cell contains a combined string. */\n  public isCombined(): number {\n    return this.content & Content.IS_COMBINED_MASK;\n  }\n  /** Width of the cell. */\n  public getWidth(): number {\n    return this.content >> Content.WIDTH_SHIFT;\n  }\n  /** JS string of the content. */\n  public getChars(): string {\n    if (this.content & Content.IS_COMBINED_MASK) {\n      return this.combinedData;\n    }\n    if (this.content & Content.CODEPOINT_MASK) {\n      return stringFromCodePoint(this.content & Content.CODEPOINT_MASK);\n    }\n    return '';\n  }\n  /**\n   * Codepoint of cell\n   * Note this returns the UTF32 codepoint of single chars,\n   * if content is a combined string it returns the codepoint\n   * of the last char in string to be in line with code in CharData.\n   * */\n  public getCode(): number {\n    return (this.isCombined())\n      ? this.combinedData.charCodeAt(this.combinedData.length - 1)\n      : this.content & Content.CODEPOINT_MASK;\n  }\n  /** Set data from CharData */\n  public setFromCharData(value: CharData): void {\n    this.fg = value[CHAR_DATA_ATTR_INDEX];\n    this.bg = 0;\n    let combined = false;\n    // surrogates and combined strings need special treatment\n    if (value[CHAR_DATA_CHAR_INDEX].length > 2) {\n      combined = true;\n    }\n    else if (value[CHAR_DATA_CHAR_INDEX].length === 2) {\n      const code = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0);\n      // if the 2-char string is a surrogate create single codepoint\n      // everything else is combined\n      if (0xD800 <= code && code <= 0xDBFF) {\n        const second = value[CHAR_DATA_CHAR_INDEX].charCodeAt(1);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          this.content = ((code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n        }\n        else {\n          combined = true;\n        }\n      }\n      else {\n        combined = true;\n      }\n    }\n    else {\n      this.content = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n    if (combined) {\n      this.combinedData = value[CHAR_DATA_CHAR_INDEX];\n      this.content = Content.IS_COMBINED_MASK | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n  }\n  /** Get data as CharData. */\n  public getAsCharData(): CharData {\n    return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, ITerminalAddon } from 'xterm';\nimport { WebglRenderer } from './WebglRenderer';\nimport { IRenderService } from 'browser/services/Services';\nimport { IColorSet } from 'browser/Types';\n\nexport class WebglAddon implements ITerminalAddon {\n  constructor(\n    private _preserveDrawingBuffer?: boolean\n  ) {}\n\n  public activate(terminal: Terminal): void {\n    if (!terminal.element) {\n      throw new Error('Cannot activate WebglRendererAddon before Terminal.open');\n    }\n    const renderService: IRenderService =  (<any>terminal)._core._renderService;\n    const colors: IColorSet = (<any>terminal)._core._colorManager.colors;\n    renderService.setRenderer(new WebglRenderer(terminal, colors, this._preserveDrawingBuffer));\n  }\n\n  public dispose(): void {\n    throw new Error('WebglRendererAddon.dispose Not yet implemented');\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { createProgram, PROJECTION_MATRIX, throwIfFalsy } from './WebglUtils';\nimport { WebglCharAtlas } from './atlas/WebglCharAtlas';\nimport { IWebGL2RenderingContext, IWebGLVertexArrayObject, IRenderModel, IRasterizedGlyph } from './Types';\nimport { INDICIES_PER_CELL } from './WebglRenderer';\nimport { COMBINED_CHAR_BIT_MASK } from './RenderModel';\nimport { fill } from 'common/TypedArrayUtils';\nimport { slice } from './TypedArray';\nimport { NULL_CELL_CODE, WHITESPACE_CELL_CODE } from 'common/buffer/Constants';\nimport { getLuminance } from './ColorUtils';\nimport { Terminal, IBufferLine } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\n\ninterface IVertices {\n  attributes: Float32Array;\n  /**\n   * These buffers are the ones used to bind to WebGL, the reason there are\n   * multiple is to allow double buffering to work as you cannot modify the\n   * buffer while it's being used by the GPU. Having multiple lets us start\n   * working on the next frame.\n   */\n  attributesBuffers: Float32Array[];\n  selectionAttributes: Float32Array;\n  count: number;\n}\n\nconst enum VertexAttribLocations {\n  UNIT_QUAD = 0,\n  CELL_POSITION = 1,\n  OFFSET = 2,\n  SIZE = 3,\n  TEXCOORD = 4,\n  TEXSIZE = 5\n}\n\nconst vertexShaderSource = `#version 300 es\nlayout (location = ${VertexAttribLocations.UNIT_QUAD}) in vec2 a_unitquad;\nlayout (location = ${VertexAttribLocations.CELL_POSITION}) in vec2 a_cellpos;\nlayout (location = ${VertexAttribLocations.OFFSET}) in vec2 a_offset;\nlayout (location = ${VertexAttribLocations.SIZE}) in vec2 a_size;\nlayout (location = ${VertexAttribLocations.TEXCOORD}) in vec2 a_texcoord;\nlayout (location = ${VertexAttribLocations.TEXSIZE}) in vec2 a_texsize;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec2 v_texcoord;\n\nvoid main() {\n  vec2 zeroToOne = (a_offset / u_resolution) + a_cellpos + (a_unitquad * a_size);\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_texcoord = a_texcoord + a_unitquad * a_texsize;\n}`;\n\nconst fragmentShaderSource = `#version 300 es\nprecision lowp float;\n\nin vec2 v_texcoord;\n\nuniform sampler2D u_texture;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = texture(u_texture, v_texcoord);\n}`;\n\nconst INDICES_PER_CELL = 10;\nconst BYTES_PER_CELL = INDICES_PER_CELL * Float32Array.BYTES_PER_ELEMENT;\nconst CELL_POSITION_INDICES = 2;\n\nexport class GlyphRenderer {\n  private _atlas: WebglCharAtlas | undefined;\n\n  private _program: WebGLProgram;\n  private _vertexArrayObject: IWebGLVertexArrayObject;\n  private _projectionLocation: WebGLUniformLocation;\n  private _resolutionLocation: WebGLUniformLocation;\n  private _textureLocation: WebGLUniformLocation;\n  private _atlasTexture: WebGLTexture;\n  private _attributesBuffer: WebGLBuffer;\n  private _activeBuffer: number = 0;\n\n  private _vertices: IVertices = {\n    count: 0,\n    attributes: new Float32Array(0),\n    attributesBuffers: [\n      new Float32Array(0),\n      new Float32Array(0)\n    ],\n    selectionAttributes: new Float32Array(0)\n  };\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl: IWebGL2RenderingContext,\n    private _dimensions: IRenderDimensions\n  ) {\n    const gl = this._gl;\n\n    const program = throwIfFalsy(createProgram(gl, vertexShaderSource, fragmentShaderSource));\n    this._program = program;\n\n    // Uniform locations\n    this._projectionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_projection'));\n    this._resolutionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_resolution'));\n    this._textureLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_texture'));\n\n    // Create and set the vertex array object\n    this._vertexArrayObject = gl.createVertexArray();\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Setup a_unitquad, this defines the 4 vertices of a rectangle\n    const unitQuadVertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n    const unitQuadVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadVerticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, unitQuadVertices, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(VertexAttribLocations.UNIT_QUAD);\n    gl.vertexAttribPointer(VertexAttribLocations.UNIT_QUAD, 2, this._gl.FLOAT, false, 0, 0);\n\n    // Setup the unit quad element array buffer, this points to indices in\n    // unitQuadVertuces to allow is to draw 2 triangles from the vertices\n    const unitQuadElementIndices = new Uint8Array([0, 1, 3, 0, 2, 3]);\n    const elementIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementIndicesBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, unitQuadElementIndices, gl.STATIC_DRAW);\n\n    // Setup attributes\n    this._attributesBuffer = throwIfFalsy(gl.createBuffer());\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.enableVertexAttribArray(VertexAttribLocations.OFFSET);\n    gl.vertexAttribPointer(VertexAttribLocations.OFFSET, 2, gl.FLOAT, false, BYTES_PER_CELL, 0);\n    gl.vertexAttribDivisor(VertexAttribLocations.OFFSET, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.SIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.SIZE, 2, gl.FLOAT, false, BYTES_PER_CELL, 2 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.SIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.TEXCOORD);\n    gl.vertexAttribPointer(VertexAttribLocations.TEXCOORD, 2, gl.FLOAT, false, BYTES_PER_CELL, 4 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.TEXCOORD, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.TEXSIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.TEXSIZE, 2, gl.FLOAT, false, BYTES_PER_CELL, 6 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.TEXSIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.CELL_POSITION);\n    gl.vertexAttribPointer(VertexAttribLocations.CELL_POSITION, 2, gl.FLOAT, false, BYTES_PER_CELL, 8 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.CELL_POSITION, 1);\n\n    // Setup empty texture atlas\n    this._atlasTexture = throwIfFalsy(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // Allow drawing of transparent texture\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    // Set viewport\n    this.onResize();\n  }\n\n  public beginFrame(): boolean {\n    return this._atlas ? this._atlas.beginFrame() : true;\n  }\n\n  public updateCell(x: number, y: number, code: number, attr: number, bg: number, fg: number, chars: string): void {\n    this._updateCell(this._vertices.attributes, x, y, code, attr, bg, fg, chars);\n  }\n\n  private _updateCell(array: Float32Array, x: number, y: number, code: number | undefined, attr: number, bg: number, fg: number, chars?: string): void {\n    const terminal = this._terminal;\n\n    const i = (y * terminal.cols + x) * INDICES_PER_CELL;\n\n    // Exit early if this is a null/space character\n    if (code === NULL_CELL_CODE || code === WHITESPACE_CELL_CODE || code === undefined/* This is used for the right side of wide chars */) {\n      fill(array, 0, i, i + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      return;\n    }\n\n    let rasterizedGlyph: IRasterizedGlyph;\n    if (!this._atlas) {\n      throw new Error('atlas must be set before updating cell');\n    }\n    if (chars && chars.length > 1) {\n      rasterizedGlyph = this._atlas.getRasterizedGlyphCombinedChar(chars, attr, bg, fg);\n    } else {\n      rasterizedGlyph = this._atlas.getRasterizedGlyph(code, attr, bg, fg);\n    }\n\n    // Fill empty if no glyph was found\n    if (!rasterizedGlyph) {\n      fill(array, 0, i, i + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      return;\n    }\n\n    // a_origin\n    array[i    ] = -rasterizedGlyph.offset.x + this._dimensions.scaledCharLeft;\n    array[i + 1] = -rasterizedGlyph.offset.y + this._dimensions.scaledCharTop;\n    // a_size\n    array[i + 2] = rasterizedGlyph.size.x / this._dimensions.scaledCanvasWidth;\n    array[i + 3] = rasterizedGlyph.size.y / this._dimensions.scaledCanvasHeight;\n    // a_texcoord\n    array[i + 4] = rasterizedGlyph.texturePositionClipSpace.x;\n    array[i + 5] = rasterizedGlyph.texturePositionClipSpace.y;\n    // a_texsize\n    array[i + 6] = rasterizedGlyph.sizeClipSpace.x;\n    array[i + 7] = rasterizedGlyph.sizeClipSpace.y;\n    // a_cellpos only changes on resize\n  }\n\n  public updateSelection(model: IRenderModel, columnSelectMode: boolean): void {\n    const terminal = this._terminal;\n\n    this._vertices.selectionAttributes = slice(this._vertices.attributes, 0);\n\n    // TODO: Make fg and bg configurable, currently since the buffer doesn't\n    // support truecolor the char atlas cannot store it.\n    const lumi = getLuminance(this._colors.background);\n    const fg = lumi > 0.5 ? 7 : 0;\n    const bg = lumi > 0.5 ? 0 : 7;\n\n    if (columnSelectMode) {\n      const startCol = model.selection.startCol;\n      const width = model.selection.endCol - startCol;\n      const height = model.selection.viewportCappedEndRow - model.selection.viewportCappedStartRow + 1;\n      for (let y = model.selection.viewportCappedStartRow; y < model.selection.viewportCappedStartRow + height; y++) {\n        this._updateSelectionRange(startCol, startCol + width, y, model, bg, fg);\n      }\n    } else {\n      // Draw first row\n      const startCol = model.selection.viewportStartRow === model.selection.viewportCappedStartRow ? model.selection.startCol : 0;\n      const startRowEndCol = model.selection.viewportCappedStartRow === model.selection.viewportCappedEndRow ? model.selection.endCol : terminal.cols;\n      this._updateSelectionRange(startCol, startRowEndCol, model.selection.viewportCappedStartRow, model, bg, fg);\n\n      // Draw middle rows\n      const middleRowsCount = Math.max(model.selection.viewportCappedEndRow - model.selection.viewportCappedStartRow - 1, 0);\n      for (let y = model.selection.viewportCappedStartRow + 1; y <= model.selection.viewportCappedStartRow + middleRowsCount; y++) {\n        this._updateSelectionRange(0, startRowEndCol, y, model, bg, fg);\n      }\n\n      // Draw final row\n      if (model.selection.viewportCappedStartRow !== model.selection.viewportCappedEndRow) {\n        // Only draw viewportEndRow if it's not the same as viewportStartRow\n        const endCol = model.selection.viewportEndRow === model.selection.viewportCappedEndRow ? model.selection.endCol : terminal.cols;\n        this._updateSelectionRange(0, endCol, model.selection.viewportCappedEndRow, model, bg, fg);\n      }\n    }\n  }\n\n  private _updateSelectionRange(startCol: number, endCol: number, y: number, model: IRenderModel, bg: number, fg: number): void {\n    const terminal = this._terminal;\n    const row = y + terminal.buffer.viewportY;\n    let line: IBufferLine | undefined;\n    for (let x = startCol; x < endCol; x++) {\n      const offset = (y * this._terminal.cols + x) * INDICIES_PER_CELL;\n      // Because the cache uses attr as a lookup key it needs to contain the selection colors as well\n      let attr = model.cells[offset + 1];\n      attr = attr & ~0x3ffff | bg << 9 | fg;\n      const code = model.cells[offset];\n      if (code & COMBINED_CHAR_BIT_MASK) {\n        if (!line) {\n          line = terminal.buffer.getLine(row);\n        }\n        const chars = line!.getCell(x)!.char;\n        this._updateCell(this._vertices.selectionAttributes, x, y, model.cells[offset], attr, bg, fg, chars);\n      } else {\n        this._updateCell(this._vertices.selectionAttributes, x, y, model.cells[offset], attr, bg, fg);\n      }\n    }\n  }\n\n  public onResize(): void {\n    const terminal = this._terminal;\n    const gl = this._gl;\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // Update vertices\n    const newCount = terminal.cols * terminal.rows * INDICES_PER_CELL;\n    if (this._vertices.count !== newCount) {\n      this._vertices.count = newCount;\n      this._vertices.attributes = new Float32Array(newCount);\n      for (let i = 0; i < this._vertices.attributesBuffers.length; i++) {\n        this._vertices.attributesBuffers[i] = new Float32Array(newCount);\n      }\n\n      let i = 0;\n      for (let y = 0; y < terminal.rows; y++) {\n        for (let x = 0; x < terminal.cols; x++) {\n          this._vertices.attributes[i + 8] = x / terminal.cols;\n          this._vertices.attributes[i + 9] = y / terminal.rows;\n          i += INDICES_PER_CELL;\n        }\n      }\n    }\n  }\n\n  public setColors(): void {\n  }\n\n  public render(renderModel: IRenderModel, isSelectionVisible: boolean): void {\n    if (!this._atlas) {\n      return;\n    }\n\n    const gl = this._gl;\n\n    gl.useProgram(this._program);\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Alternate buffers each frame as the active buffer gets locked while it's in use by the GPU\n    this._activeBuffer = (this._activeBuffer + 1) % 2;\n    const activeBuffer = this._vertices.attributesBuffers[this._activeBuffer];\n\n    // Copy data for each cell of each line up to its line length (the last non-whitespace cell)\n    // from the attributes buffer into activeBuffer, which is the one that gets bound to the GPU.\n    // The reasons for this are as follows:\n    // - So the active buffer can be alternated so we don't get blocked on rendering finishing\n    // - To copy either the normal attributes buffer or the selection attributes buffer when there\n    //   is a selection\n    // - So we don't send vertices for all the line-ending whitespace to the GPU\n    let bufferLength = 0;\n    for (let y = 0; y < renderModel.lineLengths.length; y++) {\n      const si = y * this._terminal.cols * INDICES_PER_CELL;\n      const sub = (isSelectionVisible ? this._vertices.selectionAttributes : this._vertices.attributes).subarray(si, si + renderModel.lineLengths[y] * INDICES_PER_CELL);\n      activeBuffer.set(sub, bufferLength);\n      bufferLength += sub.length;\n    }\n\n    // Bind the attributes buffer\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, activeBuffer.subarray(0, bufferLength), gl.STREAM_DRAW);\n\n    // Bind the texture atlas if it's changed\n    if (this._atlas.hasCanvasChanged) {\n      this._atlas.hasCanvasChanged = false;\n      gl.uniform1i(this._textureLocation, 0);\n      gl.activeTexture(gl.TEXTURE0 + 0);\n      gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._atlas.cacheCanvas);\n      gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    // Set uniforms\n    gl.uniformMatrix4fv(this._projectionLocation, false, PROJECTION_MATRIX);\n    gl.uniform2f(this._resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Draw the viewport\n    gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, bufferLength / INDICES_PER_CELL);\n  }\n\n  public setAtlas(atlas: WebglCharAtlas): void {\n    const gl = this._gl;\n    this._atlas = atlas;\n\n    gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlas.cacheCanvas);\n    gl.generateMipmap(gl.TEXTURE_2D);\n  }\n\n  public setDimensions(dimensions: IRenderDimensions): void {\n    this._dimensions = dimensions;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport type TypedArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray\n  | Int8Array | Int16Array | Int32Array\n  | Float32Array | Float64Array;\n\nexport function slice<T extends TypedArray>(array: T, start?: number, end?: number): T {\n  // all modern engines that support .slice\n  if (array.slice) {\n    return array.slice(start, end) as T;\n  }\n  return sliceFallback(array, start, end);\n}\n\nexport function sliceFallback<T extends TypedArray>(array: T, start: number = 0, end: number = array.length): T {\n  if (start < 0) {\n    start = (array.length + start) % array.length;\n  }\n  if (end >= array.length) {\n    end = array.length;\n  } else {\n    end = (array.length + end) % array.length;\n  }\n  start = Math.min(start, end);\n\n  const result: T = new (array.constructor as any)(end - start);\n  for (let i = 0; i < end - start; ++i) {\n    result[i] = array[i + start];\n  }\n  return result;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ILinkifierAccessor } from '../../../../src/Types';\nimport { Terminal } from 'xterm';\nimport { BaseRenderLayer } from './BaseRenderLayer';\nimport { INVERTED_DEFAULT_COLOR } from 'browser/renderer/atlas/Constants';\nimport { is256Color } from '../atlas/CharAtlasUtils';\nimport { IColorSet, ILinkifierEvent } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\n\nexport class LinkRenderLayer extends BaseRenderLayer {\n  private _state: ILinkifierEvent | undefined;\n\n  constructor(container: HTMLElement, zIndex: number, colors: IColorSet, terminal: ILinkifierAccessor) {\n    super(container, 'link', zIndex, true, colors);\n    terminal.linkifier.onLinkHover(e => this._onLinkHover(e));\n    terminal.linkifier.onLinkLeave(e => this._onLinkLeave(e));\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    super.resize(terminal, dim);\n    // Resizing the canvas discards the contents of the canvas so clear state\n    this._state = undefined;\n  }\n\n  public reset(terminal: Terminal): void {\n    this._clearCurrentLink();\n  }\n\n  private _clearCurrentLink(): void {\n    if (this._state) {\n      this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);\n      const middleRowCount = this._state.y2 - this._state.y1 - 1;\n      if (middleRowCount > 0) {\n        this._clearCells(0, this._state.y1 + 1, this._state.cols, middleRowCount);\n      }\n      this._clearCells(0, this._state.y2, this._state.x2, 1);\n      this._state = undefined;\n    }\n  }\n\n  private _onLinkHover(e: ILinkifierEvent): void {\n    if (e.fg === INVERTED_DEFAULT_COLOR) {\n      this._ctx.fillStyle = this._colors.background.css;\n    } else if (e.fg !== undefined && is256Color(e.fg)) {\n      // 256 color support\n      this._ctx.fillStyle = this._colors.ansi[e.fg!].css;\n    } else {\n      this._ctx.fillStyle = this._colors.foreground.css;\n    }\n\n    if (e.y1 === e.y2) {\n      // Single line link\n      this._fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);\n    } else {\n      // Multi-line link\n      this._fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);\n      for (let y = e.y1 + 1; y < e.y2; y++) {\n        this._fillBottomLineAtCells(0, y, e.cols);\n      }\n      this._fillBottomLineAtCells(0, e.y2, e.x2);\n    }\n    this._state = e;\n  }\n\n  private _onLinkLeave(e: ILinkifierEvent): void {\n    this._clearCurrentLink();\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ICharAtlasConfig } from './Types';\nimport { DIM_OPACITY, INVERTED_DEFAULT_COLOR } from 'browser/renderer/atlas/Constants';\nimport { IRasterizedGlyph, IBoundingBox, IRasterizedGlyphSet } from '../Types';\nimport { DEFAULT_COLOR, DEFAULT_ATTR } from 'common/buffer/Constants';\nimport { is256Color } from './CharAtlasUtils';\nimport { throwIfFalsy } from '../WebglUtils';\nimport { IColor } from 'browser/Types';\nimport { FLAGS } from '../Constants';\nimport { IDisposable } from 'xterm';\n\n// In practice we're probably never going to exhaust a texture this large. For debugging purposes,\n// however, it can be useful to set this to a really tiny value, to verify that LRU eviction works.\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 1024;\n\n/**\n * The amount of the texture to be filled before throwing it away and starting\n * again. Since the throw away and individual glyph draws don't cost too much,\n * this prevent juggling multiple textures in the GL context.\n */\nconst TEXTURE_CAPACITY = Math.floor(TEXTURE_HEIGHT * 0.8);\n\nconst TRANSPARENT_COLOR = {\n  css: 'rgba(0, 0, 0, 0)',\n  rgba: 0\n};\n\n/**\n * A shared object which is used to draw nothing for a particular cell.\n */\nconst NULL_RASTERIZED_GLYPH: IRasterizedGlyph = {\n  offset: { x: 0, y: 0 },\n  texturePosition: { x: 0, y: 0 },\n  texturePositionClipSpace: { x: 0, y: 0 },\n  size: { x: 0, y: 0 },\n  sizeClipSpace: { x: 0, y: 0 }\n};\n\nconst TMP_CANVAS_GLYPH_PADDING = 2;\n\nexport class WebglCharAtlas implements IDisposable {\n  private _didWarmUp: boolean = false;\n\n  private _cacheMap: { [code: number]: IRasterizedGlyphSet } = {};\n  private _cacheMapCombined: { [chars: string]: IRasterizedGlyphSet } = {};\n\n  // The texture that the atlas is drawn to\n  public cacheCanvas: HTMLCanvasElement;\n  private _cacheCtx: CanvasRenderingContext2D;\n\n  private _tmpCanvas: HTMLCanvasElement;\n  // A temporary context that glyphs are drawn to before being transfered to the atlas.\n  private _tmpCtx: CanvasRenderingContext2D;\n\n  // Since glyphs are expected to be around the same height, the packing\n  // strategy used it to fill a row with glyphs while keeping track of the\n  // tallest glyph in the row. Once the row is full a new row is started at\n  // (0,lastRow+lastRowTallestGlyph).\n  private _currentRowY: number = 0;\n  private _currentRowX: number = 0;\n  private _currentRowHeight: number = 0;\n\n  public hasCanvasChanged = false;\n\n  private _workBoundingBox: IBoundingBox = { top: 0, left: 0, bottom: 0, right: 0 };\n\n  constructor(document: Document, private _config: ICharAtlasConfig) {\n    this.cacheCanvas = document.createElement('canvas');\n    this.cacheCanvas.width = TEXTURE_WIDTH;\n    this.cacheCanvas.height = TEXTURE_HEIGHT;\n    // The canvas needs alpha because we use clearColor to convert the background color to alpha.\n    // It might also contain some characters with transparent backgrounds if allowTransparency is\n    // set.\n    this._cacheCtx = throwIfFalsy(this.cacheCanvas.getContext('2d', {alpha: true}));\n\n    this._tmpCanvas = document.createElement('canvas');\n    this._tmpCanvas.width = this._config.scaledCharWidth * 2 + TMP_CANVAS_GLYPH_PADDING * 2;\n    this._tmpCanvas.height = this._config.scaledCharHeight + TMP_CANVAS_GLYPH_PADDING * 2;\n    this._tmpCtx = throwIfFalsy(this._tmpCanvas.getContext('2d', {alpha: this._config.allowTransparency}));\n\n    // This is useful for debugging\n    document.body.appendChild(this.cacheCanvas);\n  }\n\n  public dispose(): void {\n    if (this.cacheCanvas.parentElement) {\n      this.cacheCanvas.parentElement.removeChild(this.cacheCanvas);\n    }\n  }\n\n  public warmUp(): void {\n    if (!this._didWarmUp) {\n      this._doWarmUp();\n      this._didWarmUp = true;\n    }\n  }\n\n  protected _doWarmUp(): void {\n    // Pre-fill with ASCII 33-126\n    for (let i = 33; i < 126; i++) {\n      const rasterizedGlyph = this._drawToCache(i, DEFAULT_ATTR, DEFAULT_COLOR, DEFAULT_COLOR);\n      this._cacheMap[i] = {\n        [DEFAULT_ATTR]: rasterizedGlyph\n      };\n    }\n  }\n\n  public beginFrame(): boolean {\n    if (this._currentRowY > TEXTURE_CAPACITY) {\n      this._cacheCtx.clearRect(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n      this._cacheMap = {};\n      this._currentRowHeight = 0;\n      this._currentRowX = 0;\n      this._currentRowY = 0;\n      this._doWarmUp();\n      return true;\n    }\n    return false;\n  }\n\n  public getRasterizedGlyphCombinedChar(chars: string, attr: number, bg: number, fg: number): IRasterizedGlyph {\n    let rasterizedGlyphSet = this._cacheMapCombined[chars];\n    if (!rasterizedGlyphSet) {\n      rasterizedGlyphSet = {};\n      this._cacheMapCombined[chars] = rasterizedGlyphSet;\n    }\n    let rasterizedGlyph = rasterizedGlyphSet[attr];\n    if (!rasterizedGlyph) {\n      rasterizedGlyph = this._drawToCache(chars, attr, bg, fg);\n      rasterizedGlyphSet[attr] = rasterizedGlyph;\n    }\n    return rasterizedGlyph;\n  }\n\n  /**\n   * Gets the glyphs texture coords, drawing the texture if it's not already\n   */\n  public getRasterizedGlyph(code: number, attr: number, bg: number, fg: number): IRasterizedGlyph {\n    let rasterizedGlyphSet = this._cacheMap[code];\n    if (!rasterizedGlyphSet) {\n      rasterizedGlyphSet = {};\n      this._cacheMap[code] = rasterizedGlyphSet;\n    }\n    let rasterizedGlyph = rasterizedGlyphSet[attr];\n    if (!rasterizedGlyph) {\n      rasterizedGlyph = this._drawToCache(code, attr, bg, fg);\n      rasterizedGlyphSet[attr] = rasterizedGlyph;\n    }\n    return rasterizedGlyph;\n  }\n\n  private _getColorFromAnsiIndex(idx: number): IColor {\n    if (idx >= this._config.colors.ansi.length) {\n      throw new Error('No color found for idx ' + idx);\n    }\n    return this._config.colors.ansi[idx];\n  }\n\n  private _getBackgroundColor(bg: number): IColor {\n    if (this._config.allowTransparency) {\n      // The background color might have some transparency, so we need to render it as fully\n      // transparent in the atlas. Otherwise we'd end up drawing the transparent background twice\n      // around the anti-aliased edges of the glyph, and it would look too dark.\n      return TRANSPARENT_COLOR;\n    } else if (bg === INVERTED_DEFAULT_COLOR) {\n      return this._config.colors.foreground;\n    } else if (is256Color(bg)) {\n      return this._getColorFromAnsiIndex(bg);\n    }\n    // TODO: Support true color\n    return this._config.colors.background;\n  }\n\n  private _getForegroundColor(fg: number): IColor {\n    if (fg === INVERTED_DEFAULT_COLOR) {\n      return this._config.colors.background;\n    } else if (is256Color(fg)) {\n      return this._getColorFromAnsiIndex(fg);\n    }\n    // TODO: Support true color\n    return this._config.colors.foreground;\n  }\n\n  private _drawToCache(code: number, attr: number, bg: number, fg: number): IRasterizedGlyph;\n  private _drawToCache(chars: string, attr: number, bg: number, fg: number): IRasterizedGlyph;\n  private _drawToCache(codeOrChars: number | string, attr: number, bg: number, fg: number): IRasterizedGlyph {\n    const chars = typeof codeOrChars === 'number' ? String.fromCharCode(codeOrChars) : codeOrChars;\n\n    this.hasCanvasChanged = true;\n\n    const flags = attr >> 18;\n\n    const bold = !!(flags & FLAGS.BOLD);\n    const dim = !!(flags & FLAGS.DIM);\n    const italic = !!(flags & FLAGS.ITALIC);\n\n    this._tmpCtx.save();\n\n    // draw the background\n    const backgroundColor = this._getBackgroundColor(bg);\n    // Use a 'copy' composite operation to clear any existing glyph out of _tmpCtxWithAlpha, regardless of\n    // transparency in backgroundColor\n    this._tmpCtx.globalCompositeOperation = 'copy';\n    this._tmpCtx.fillStyle = backgroundColor.css;\n    this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height);\n    this._tmpCtx.globalCompositeOperation = 'source-over';\n\n    // draw the foreground/glyph\n    const fontWeight = bold ? this._config.fontWeightBold : this._config.fontWeight;\n    const fontStyle = italic ? 'italic' : '';\n    this._tmpCtx.font =\n      `${fontStyle} ${fontWeight} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`;\n    this._tmpCtx.textBaseline = 'top';\n\n    this._tmpCtx.fillStyle = this._getForegroundColor(fg).css;\n\n    // Apply alpha to dim the character\n    if (dim) {\n      this._tmpCtx.globalAlpha = DIM_OPACITY;\n    }\n\n    // Draw the character\n    this._tmpCtx.fillText(chars, TMP_CANVAS_GLYPH_PADDING, TMP_CANVAS_GLYPH_PADDING);\n    this._tmpCtx.restore();\n\n    // clear the background from the character to avoid issues with drawing over the previous\n    // character if it extends past it's bounds\n    const imageData = this._tmpCtx.getImageData(\n      0, 0, this._tmpCanvas.width, this._tmpCanvas.height\n    );\n\n    // TODO: Support transparency\n    // let isEmpty = false;\n    // if (!this._config.allowTransparency) {\n    //   isEmpty = clearColor(imageData, backgroundColor);\n    // }\n\n    // Clear out the background color and determine if the glyph is empty.\n    const isEmpty = clearColor(imageData, backgroundColor);\n\n    // Handle empty glyphs\n    if (isEmpty) {\n      return NULL_RASTERIZED_GLYPH;\n    }\n\n    const rasterizedGlyph = this._findGlyphBoundingBox(imageData, this._workBoundingBox);\n    const clippedImageData = this._clipImageData(imageData, this._workBoundingBox);\n\n    // Check if there is enough room in the current row and go to next if needed\n    if (this._currentRowX + this._config.scaledCharWidth > TEXTURE_WIDTH) {\n      this._currentRowX = 0;\n      this._currentRowY += this._currentRowHeight;\n      this._currentRowHeight = 0;\n    }\n\n    // Record texture position\n    rasterizedGlyph.texturePosition.x = this._currentRowX;\n    rasterizedGlyph.texturePosition.y = this._currentRowY;\n    rasterizedGlyph.texturePositionClipSpace.x = this._currentRowX / TEXTURE_WIDTH;\n    rasterizedGlyph.texturePositionClipSpace.y = this._currentRowY / TEXTURE_HEIGHT;\n\n    // Update atlas current row\n    this._currentRowHeight = Math.max(this._currentRowHeight, rasterizedGlyph.size.y);\n    this._currentRowX += rasterizedGlyph.size.x;\n\n    // putImageData doesn't do any blending, so it will overwrite any existing cache entry for us\n    this._cacheCtx.putImageData(clippedImageData, rasterizedGlyph.texturePosition.x, rasterizedGlyph.texturePosition.y);\n\n    return rasterizedGlyph;\n  }\n\n  /**\n   * Given an ImageData object, find the bounding box of the non-transparent\n   * portion of the texture and return an IRasterizedGlyph with these\n   * dimensions.\n   * @param imageData The image data to read.\n   * @param boundingBox An IBoundingBox to put the clipped bounding box values.\n   */\n  private _findGlyphBoundingBox(imageData: ImageData, boundingBox: IBoundingBox): IRasterizedGlyph {\n    boundingBox.top = 0;\n    let found = false;\n    for (let y = 0; y < this._tmpCanvas.height; y++) {\n      for (let x = 0; x < this._tmpCanvas.width; x++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.top = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.left = 0;\n    found = false;\n    for (let x = 0; x < this._tmpCanvas.width; x++) {\n      for (let y = 0; y < this._tmpCanvas.height; y++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.left = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.right = this._tmpCanvas.width;\n    found = false;\n    for (let x = this._tmpCanvas.width - 1; x >= 0; x--) {\n      for (let y = 0; y < this._tmpCanvas.height; y++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.right = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.bottom = this._tmpCanvas.height;\n    found = false;\n    for (let y = this._tmpCanvas.height - 1; y >= 0; y--) {\n      for (let x = 0; x < this._tmpCanvas.width; x++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.bottom = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    return {\n      texturePosition: { x: 0, y: 0 },\n      texturePositionClipSpace: { x: 0, y: 0 },\n      size: {\n        x: boundingBox.right - boundingBox.left + 1,\n        y: boundingBox.bottom - boundingBox.top + 1\n      },\n      sizeClipSpace: {\n        x: (boundingBox.right - boundingBox.left + 1) / TEXTURE_WIDTH,\n        y: (boundingBox.bottom - boundingBox.top + 1) / TEXTURE_HEIGHT\n      },\n      offset: {\n        x: -boundingBox.left + TMP_CANVAS_GLYPH_PADDING,\n        y: -boundingBox.top + TMP_CANVAS_GLYPH_PADDING\n      }\n    };\n  }\n\n  private _clipImageData(imageData: ImageData, boundingBox: IBoundingBox): ImageData {\n    const width = boundingBox.right - boundingBox.left + 1;\n    const height = boundingBox.bottom - boundingBox.top + 1;\n    const clippedData = new Uint8ClampedArray(width * height * 4);\n    for (let y = boundingBox.top; y <= boundingBox.bottom; y++) {\n      for (let x = boundingBox.left; x <= boundingBox.right; x++) {\n        const oldOffset = y * this._tmpCanvas.width * 4 + x * 4;\n        const newOffset = (y - boundingBox.top) * width * 4 + (x - boundingBox.left) * 4;\n        clippedData[newOffset] = imageData.data[oldOffset];\n        clippedData[newOffset + 1] = imageData.data[oldOffset + 1];\n        clippedData[newOffset + 2] = imageData.data[oldOffset + 2];\n        clippedData[newOffset + 3] = imageData.data[oldOffset + 3];\n      }\n    }\n    return new ImageData(clippedData, width, height);\n  }\n}\n\n/**\n * Makes a partiicular rgb color in an ImageData completely transparent.\n * @returns True if the result is \"empty\", meaning all pixels are fully transparent.\n */\nfunction clearColor(imageData: ImageData, color: IColor): boolean {\n  let isEmpty = true;\n  const r = color.rgba >>> 24;\n  const g = color.rgba >>> 16 & 0xFF;\n  const b = color.rgba >>> 8 & 0xFF;\n  for (let offset = 0; offset < imageData.data.length; offset += 4) {\n    if (imageData.data[offset] === r &&\n        imageData.data[offset + 1] === g &&\n        imageData.data[offset + 2] === b) {\n      imageData.data[offset + 3] = 0;\n    } else {\n      isEmpty = false;\n    }\n  }\n  return isEmpty;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { BaseRenderLayer } from './BaseRenderLayer';\nimport { ICellData } from 'common/Types';\nimport { CellData } from 'common/buffer/CellData';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\n\ninterface ICursorState {\n  x: number;\n  y: number;\n  isFocused: boolean;\n  style: string;\n  width: number;\n}\n\n/**\n * The time between cursor blinks.\n */\nconst BLINK_INTERVAL = 600;\n\nexport class CursorRenderLayer extends BaseRenderLayer {\n  private _state: ICursorState;\n  private _cursorRenderers: {[key: string]: (terminal: Terminal, x: number, y: number, cell: ICellData) => void};\n  private _cursorBlinkStateManager: CursorBlinkStateManager | undefined;\n  private _cell: ICellData = new CellData();\n\n  constructor(container: HTMLElement, zIndex: number, colors: IColorSet) {\n    super(container, 'cursor', zIndex, true, colors);\n    this._state = {\n      x: 0,\n      y: 0,\n      isFocused: false,\n      style: '',\n      width: 0\n    };\n    this._cursorRenderers = {\n      'bar': this._renderBarCursor.bind(this),\n      'block': this._renderBlockCursor.bind(this),\n      'underline': this._renderUnderlineCursor.bind(this)\n    };\n    // TODO: Consider initial options? Maybe onOptionsChanged should be called at the end of open?\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    super.resize(terminal, dim);\n    // Resizing the canvas discards the contents of the canvas so clear state\n    this._state = {\n      x: 0,\n      y: 0,\n      isFocused: false,\n      style: '',\n      width: 0\n    };\n  }\n\n  public reset(terminal: Terminal): void {\n    this._clearCursor();\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.dispose();\n      this.onOptionsChanged(terminal);\n    }\n  }\n\n  public onBlur(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.pause();\n    }\n    terminal.refresh(terminal.buffer.cursorY, terminal.buffer.cursorY);\n  }\n\n  public onFocus(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.resume(terminal);\n    } else {\n      terminal.refresh(terminal.buffer.cursorY, terminal.buffer.cursorY);\n    }\n  }\n\n  public onOptionsChanged(terminal: Terminal): void {\n    if (terminal.getOption('cursorBlink')) {\n      if (!this._cursorBlinkStateManager) {\n        this._cursorBlinkStateManager = new CursorBlinkStateManager(terminal, () => {\n          this._render(terminal, true);\n        });\n      }\n    } else {\n      if (this._cursorBlinkStateManager) {\n        this._cursorBlinkStateManager.dispose();\n      }\n    }\n    // Request a refresh from the terminal as management of rendering is being\n    // moved back to the terminal\n    terminal.refresh(terminal.buffer.cursorY, terminal.buffer.cursorY);\n  }\n\n  public onCursorMove(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.restartBlinkAnimation(terminal);\n    }\n  }\n\n  public onGridChanged(terminal: Terminal, startRow: number, endRow: number): void {\n    if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused) {\n      this._render(terminal, false);\n    } else {\n      this._cursorBlinkStateManager.restartBlinkAnimation(terminal);\n    }\n  }\n\n  private _render(terminal: Terminal, triggeredByAnimationFrame: boolean): void {\n    // Don't draw the cursor if it's hidden\n    // TODO: Need to expose API for this\n    if (!(terminal as any)._core.cursorState || (terminal as any)._core.cursorHidden) {\n      this._clearCursor();\n      return;\n    }\n\n    const cursorY = terminal.buffer.baseY + terminal.buffer.cursorY;\n    const viewportRelativeCursorY = cursorY - terminal.buffer.viewportY;\n\n    // Don't draw the cursor if it's off-screen\n    if (viewportRelativeCursorY < 0 || viewportRelativeCursorY >= terminal.rows) {\n      this._clearCursor();\n      return;\n    }\n\n    // TODO: Need fast buffer API for loading cell\n    (terminal as any)._core.buffer.lines.get(cursorY).loadCell(terminal.buffer.cursorX, this._cell);\n    if (this._cell.content === undefined) {\n      return;\n    }\n\n    if (!isTerminalFocused(terminal)) {\n      this._clearCursor();\n      this._ctx.save();\n      this._ctx.fillStyle = this._colors.cursor.css;\n      const cursorStyle = terminal.getOption('cursorStyle');\n      if (cursorStyle && cursorStyle !== 'block') {\n        this._cursorRenderers[cursorStyle](terminal, terminal.buffer.cursorX, viewportRelativeCursorY, this._cell);\n      } else {\n        this._renderBlurCursor(terminal, terminal.buffer.cursorX, viewportRelativeCursorY, this._cell);\n      }\n      this._ctx.restore();\n      this._state.x = terminal.buffer.cursorX;\n      this._state.y = viewportRelativeCursorY;\n      this._state.isFocused = false;\n      this._state.style = cursorStyle;\n      this._state.width = this._cell.getWidth();\n      return;\n    }\n\n    // Don't draw the cursor if it's blinking\n    if (this._cursorBlinkStateManager && !this._cursorBlinkStateManager.isCursorVisible) {\n      this._clearCursor();\n      return;\n    }\n\n    if (this._state) {\n      // The cursor is already in the correct spot, don't redraw\n      if (this._state.x === terminal.buffer.cursorX &&\n          this._state.y === viewportRelativeCursorY &&\n          this._state.isFocused === isTerminalFocused(terminal) &&\n          this._state.style === terminal.getOption('cursorStyle') &&\n          this._state.width === this._cell.getWidth()) {\n        return;\n      }\n      this._clearCursor();\n    }\n\n    this._ctx.save();\n    this._cursorRenderers[terminal.getOption('cursorStyle') || 'block'](terminal, terminal.buffer.cursorX, viewportRelativeCursorY, this._cell);\n    this._ctx.restore();\n\n    this._state.x = terminal.buffer.cursorX;\n    this._state.y = viewportRelativeCursorY;\n    this._state.isFocused = false;\n    this._state.style = terminal.getOption('cursorStyle');\n    this._state.width = this._cell.getWidth();\n  }\n\n  private _clearCursor(): void {\n    if (this._state) {\n      this._clearCells(this._state.x, this._state.y, this._state.width, 1);\n      this._state = {\n        x: 0,\n        y: 0,\n        isFocused: false,\n        style: '',\n        width: 0\n      };\n    }\n  }\n\n  private _renderBarCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillLeftLineAtCell(x, y);\n    this._ctx.restore();\n  }\n\n  private _renderBlockCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillCells(x, y, cell.getWidth(), 1);\n    this._ctx.fillStyle = this._colors.cursorAccent.css;\n    this._fillCharTrueColor(terminal, cell, x, y);\n    this._ctx.restore();\n  }\n\n  private _renderUnderlineCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillBottomLineAtCells(x, y);\n    this._ctx.restore();\n  }\n\n  private _renderBlurCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.strokeStyle = this._colors.cursor.css;\n    this._strokeRectAtCell(x, y, cell.getWidth(), 1);\n    this._ctx.restore();\n  }\n}\n\nclass CursorBlinkStateManager {\n  public isCursorVisible: boolean;\n\n  private _animationFrame: number | undefined;\n  private _blinkStartTimeout: number | undefined;\n  private _blinkInterval: number | undefined;\n\n  /**\n   * The time at which the animation frame was restarted, this is used on the\n   * next render to restart the timers so they don't need to restart the timers\n   * multiple times over a short period.\n   */\n  private _animationTimeRestarted: number | undefined;\n\n  constructor(\n    terminal: Terminal,\n    private _renderCallback: () => void\n  ) {\n    this.isCursorVisible = true;\n    if (isTerminalFocused(terminal)) {\n      this._restartInterval();\n    }\n  }\n\n  public get isPaused(): boolean { return !(this._blinkStartTimeout || this._blinkInterval); }\n\n  public dispose(): void {\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n      this._blinkInterval = undefined;\n    }\n    if (this._blinkStartTimeout) {\n      window.clearTimeout(this._blinkStartTimeout);\n      this._blinkStartTimeout = undefined;\n    }\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n      this._animationFrame = undefined;\n    }\n  }\n\n  public restartBlinkAnimation(terminal: Terminal): void {\n    if (this.isPaused) {\n      return;\n    }\n    // Save a timestamp so that the restart can be done on the next interval\n    this._animationTimeRestarted = Date.now();\n    // Force a cursor render to ensure it's visible and in the correct position\n    this.isCursorVisible = true;\n    if (!this._animationFrame) {\n      this._animationFrame = window.requestAnimationFrame(() => {\n        this._renderCallback();\n        this._animationFrame = undefined;\n      });\n    }\n  }\n\n  private _restartInterval(timeToStart: number = BLINK_INTERVAL): void {\n    // Clear any existing interval\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n    }\n\n    // Setup the initial timeout which will hide the cursor, this is done before\n    // the regular interval is setup in order to support restarting the blink\n    // animation in a lightweight way (without thrashing clearInterval and\n    // setInterval).\n    this._blinkStartTimeout = <number><any>setTimeout(() => {\n      // Check if another animation restart was requested while this was being\n      // started\n      if (this._animationTimeRestarted) {\n        const time = BLINK_INTERVAL - (Date.now() - this._animationTimeRestarted);\n        this._animationTimeRestarted = undefined;\n        if (time > 0) {\n          this._restartInterval(time);\n          return;\n        }\n      }\n\n      // Hide the cursor\n      this.isCursorVisible = false;\n      this._animationFrame = window.requestAnimationFrame(() => {\n        this._renderCallback();\n        this._animationFrame = undefined;\n      });\n\n      // Setup the blink interval\n      this._blinkInterval = <number><any>setInterval(() => {\n        // Adjust the animation time if it was restarted\n        if (this._animationTimeRestarted) {\n          // calc time diff\n          // Make restart interval do a setTimeout initially?\n          const time = BLINK_INTERVAL - (Date.now() - this._animationTimeRestarted);\n          this._animationTimeRestarted = undefined;\n          this._restartInterval(time);\n          return;\n        }\n\n        // Invert visibility and render\n        this.isCursorVisible = !this.isCursorVisible;\n        this._animationFrame = window.requestAnimationFrame(() => {\n          this._renderCallback();\n          this._animationFrame = undefined;\n        });\n      }, BLINK_INTERVAL);\n    }, timeToStart);\n  }\n\n  public pause(): void {\n    this.isCursorVisible = true;\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n      this._blinkInterval = undefined;\n    }\n    if (this._blinkStartTimeout) {\n      window.clearTimeout(this._blinkStartTimeout);\n      this._blinkStartTimeout = undefined;\n    }\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n      this._animationFrame = undefined;\n    }\n  }\n\n  public resume(terminal: Terminal): void {\n    this._animationTimeRestarted = undefined;\n    this._restartInterval();\n    this.restartBlinkAnimation(terminal);\n  }\n}\n\nfunction isTerminalFocused(terminal: Terminal): boolean {\n  return document.activeElement === terminal.textarea && document.hasFocus();\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * Polyfill - Convert UTF32 codepoint into JS string.\n * Note: The built-in String.fromCodePoint happens to be much slower\n *       due to additional sanity checks. We can avoid them since\n *       we always operate on legal UTF32 (granted by the input decoders)\n *       and use this faster version instead.\n */\nexport function stringFromCodePoint(codePoint: number): string {\n  if (codePoint > 0xFFFF) {\n    codePoint -= 0x10000;\n    return String.fromCharCode((codePoint >> 10) + 0xD800) + String.fromCharCode((codePoint % 0x400) + 0xDC00);\n  }\n  return String.fromCharCode(codePoint);\n}\n\n/**\n * Convert UTF32 char codes into JS string.\n * Basically the same as `stringFromCodePoint` but for multiple codepoints\n * in a loop (which is a lot faster).\n */\nexport function utf32ToString(data: Uint32Array, start: number = 0, end: number = data.length): string {\n  let result = '';\n  for (let i = start; i < end; ++i) {\n    let codepoint = data[i];\n    if (codepoint > 0xFFFF) {\n      // JS strings are encoded as UTF16, thus a non BMP codepoint gets converted into a surrogate pair\n      // conversion rules:\n      //  - subtract 0x10000 from code point, leaving a 20 bit number\n      //  - add high 10 bits to 0xD800  --> first surrogate\n      //  - add low 10 bits to 0xDC00   --> second surrogate\n      codepoint -= 0x10000;\n      result += String.fromCharCode((codepoint >> 10) + 0xD800) + String.fromCharCode((codepoint % 0x400) + 0xDC00);\n    } else {\n      result += String.fromCharCode(codepoint);\n    }\n  }\n  return result;\n}\n\n/**\n * StringToUtf32 - decodes UTF16 sequences into UTF32 codepoints.\n * To keep the decoder in line with JS strings it handles single surrogates as UCS2.\n */\nexport class StringToUtf32 {\n  private _interim: number = 0;\n\n  /**\n   * Clears interim and resets decoder to clean state.\n   */\n  public clear(): void {\n    this._interim = 0;\n  }\n\n  /**\n   * Decode JS string to UTF32 codepoints.\n   * The methods assumes stream input and will store partly transmitted\n   * surrogate pairs and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided input data does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  decode(input: string, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let startPos = 0;\n\n    // handle leftover surrogate high\n    if (this._interim) {\n      const second = input.charCodeAt(startPos++);\n      if (0xDC00 <= second && second <= 0xDFFF) {\n        target[size++] = (this._interim - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      } else {\n        // illegal codepoint (USC2 handling)\n        target[size++] = this._interim;\n        target[size++] = second;\n      }\n      this._interim = 0;\n    }\n\n    for (let i = startPos; i < length; ++i) {\n      const code = input.charCodeAt(i);\n      // surrogate pair first\n      if (0xD800 <= code && code <= 0xDBFF) {\n        if (++i >= length) {\n          this._interim = code;\n          return size;\n        }\n        const second = input.charCodeAt(i);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          target[size++] = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        } else {\n          // illegal codepoint (USC2 handling)\n          target[size++] = code;\n          target[size++] = second;\n        }\n        continue;\n      }\n      target[size++] = code;\n    }\n    return size;\n  }\n}\n\n/**\n * Utf8Decoder - decodes UTF8 byte sequences into UTF32 codepoints.\n */\nexport class Utf8ToUtf32 {\n  public interim: Uint8Array = new Uint8Array(3);\n\n  /**\n   * Clears interim bytes and resets decoder to clean state.\n   */\n  public clear(): void {\n    this.interim.fill(0);\n  }\n\n  /**\n   * Decodes UTF8 byte sequences in `input` to UTF32 codepoints in `target`.\n   * The methods assumes stream input and will store partly transmitted bytes\n   * and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided data chunk does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  decode(input: Uint8Array, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let byte1: number;\n    let byte2: number;\n    let byte3: number;\n    let byte4: number;\n    let codepoint = 0;\n    let startPos = 0;\n\n    // handle leftover bytes\n    if (this.interim[0]) {\n      let discardInterim = false;\n      let cp = this.interim[0];\n      cp &= ((((cp & 0xE0) === 0xC0)) ? 0x1F : (((cp & 0xF0) === 0xE0)) ? 0x0F : 0x07);\n      let pos = 0;\n      let tmp: number;\n      while ((tmp = this.interim[++pos] & 0x3F) && pos < 4) {\n        cp <<= 6;\n        cp |= tmp;\n      }\n      // missing bytes - read ahead from input\n      const type = (((this.interim[0] & 0xE0) === 0xC0)) ? 2 : (((this.interim[0] & 0xF0) === 0xE0)) ? 3 : 4;\n      const missing = type - pos;\n      while (startPos < missing) {\n        if (startPos >= length) {\n          return 0;\n        }\n        tmp = input[startPos++];\n        if ((tmp & 0xC0) !== 0x80) {\n          // wrong continuation, discard interim bytes completely\n          startPos--;\n          discardInterim = true;\n          break;\n        } else {\n          // need to save so we can continue short inputs in next call\n          this.interim[pos++] = tmp;\n          cp <<= 6;\n          cp |= tmp & 0x3F;\n        }\n      }\n      if (!discardInterim) {\n        // final test is type dependent\n        if (type === 2) {\n          if (cp < 0x80) {\n            // wrong starter byte\n            startPos--;\n          } else {\n            target[size++] = cp;\n          }\n        } else if (type === 3) {\n          if (cp < 0x0800 || (cp >= 0xD800 && cp <= 0xDFFF)) {\n            // illegal codepoint\n          } else {\n            target[size++] = cp;\n          }\n        } else {\n          if (cp < 0x010000 || cp > 0x10FFFF) {\n            // illegal codepoint\n          } else {\n            target[size++] = cp;\n          }\n        }\n      }\n      this.interim.fill(0);\n    }\n\n    // loop through input\n    const fourStop = length - 4;\n    let i = startPos;\n    while (i < length) {\n      /**\n       * ASCII shortcut with loop unrolled to 4 consecutive ASCII chars.\n       * This is a compromise between speed gain for ASCII\n       * and penalty for non ASCII:\n       * For best ASCII performance the char should be stored directly into target,\n       * but even a single attempt to write to target and compare afterwards\n       * penalizes non ASCII really bad (-50%), thus we load the char into byteX first,\n       * which reduces ASCII performance by ~15%.\n       * This trial for ASCII reduces non ASCII performance by ~10% which seems acceptible\n       * compared to the gains.\n       * Note that this optimization only takes place for 4 consecutive ASCII chars,\n       * for any shorter it bails out. Worst case - all 4 bytes being read but\n       * thrown away due to the last being a non ASCII char (-10% performance).\n       */\n      while (i < fourStop\n        && !((byte1 = input[i]) & 0x80)\n        && !((byte2 = input[i + 1]) & 0x80)\n        && !((byte3 = input[i + 2]) & 0x80)\n        && !((byte4 = input[i + 3]) & 0x80))\n      {\n        target[size++] = byte1;\n        target[size++] = byte2;\n        target[size++] = byte3;\n        target[size++] = byte4;\n        i += 4;\n      }\n\n      // reread byte1\n      byte1 = input[i++];\n\n      // 1 byte\n      if (byte1 < 0x80) {\n        target[size++] = byte1;\n\n        // 2 bytes\n      } else if ((byte1 & 0xE0) === 0xC0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x1F) << 6 | (byte2 & 0x3F);\n        if (codepoint < 0x80) {\n          // wrong starter byte\n          i--;\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 3 bytes\n      } else if ((byte1 & 0xF0) === 0xE0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x0F) << 12 | (byte2 & 0x3F) << 6 | (byte3 & 0x3F);\n        if (codepoint < 0x0800 || (codepoint >= 0xD800 && codepoint <= 0xDFFF)) {\n          // illegal codepoint, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 4 bytes\n      } else if ((byte1 & 0xF8) === 0xF0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          this.interim[2] = byte3;\n          return size;\n        }\n        byte4 = input[i++];\n        if ((byte4 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x07) << 18 | (byte2 & 0x3F) << 12 | (byte3 & 0x3F) << 6 | (byte4 & 0x3F);\n        if (codepoint < 0x010000 || codepoint > 0x10FFFF) {\n          // illegal codepoint, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n      } else {\n        // illegal byte, just skip\n      }\n    }\n    return size;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IAttributeData, IColorRGB } from 'common/Types';\nimport { Attributes, FgFlags, BgFlags } from 'common/buffer/Constants';\n\nexport class AttributeData implements IAttributeData {\n  static toColorRGB(value: number): IColorRGB {\n    return [\n      value >>> Attributes.RED_SHIFT & 255,\n      value >>> Attributes.GREEN_SHIFT & 255,\n      value & 255\n    ];\n  }\n  static fromColorRGB(value: IColorRGB): number {\n    return (value[0] & 255) << Attributes.RED_SHIFT | (value[1] & 255) << Attributes.GREEN_SHIFT | value[2] & 255;\n  }\n\n  public clone(): IAttributeData {\n    const newObj = new AttributeData();\n    newObj.fg = this.fg;\n    newObj.bg = this.bg;\n    return newObj;\n  }\n\n  // data\n  public fg: number = 0;\n  public bg: number = 0;\n\n  // flags\n  public isInverse(): number   { return this.fg & FgFlags.INVERSE; }\n  public isBold(): number      { return this.fg & FgFlags.BOLD; }\n  public isUnderline(): number { return this.fg & FgFlags.UNDERLINE; }\n  public isBlink(): number     { return this.fg & FgFlags.BLINK; }\n  public isInvisible(): number { return this.fg & FgFlags.INVISIBLE; }\n  public isItalic(): number    { return this.bg & BgFlags.ITALIC; }\n  public isDim(): number       { return this.bg & BgFlags.DIM; }\n\n  // color modes\n  public getFgColorMode(): number { return this.fg & Attributes.CM_MASK; }\n  public getBgColorMode(): number { return this.bg & Attributes.CM_MASK; }\n  public isFgRGB(): boolean       { return (this.fg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isBgRGB(): boolean       { return (this.bg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isFgPalette(): boolean   { return (this.fg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.fg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isBgPalette(): boolean   { return (this.bg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.bg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isFgDefault(): boolean   { return (this.fg & Attributes.CM_MASK) === 0; }\n  public isBgDefault(): boolean   { return (this.bg & Attributes.CM_MASK) === 0; }\n\n  // colors\n  public getFgColor(): number {\n    switch (this.fg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.fg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.fg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n  public getBgColor(): number {\n    switch (this.bg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.bg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.bg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { createProgram, expandFloat32Array, PROJECTION_MATRIX, throwIfFalsy } from './WebglUtils';\nimport { IRenderModel, IWebGLVertexArrayObject, IWebGL2RenderingContext, ISelectionRenderModel } from './Types';\nimport { fill } from 'common/TypedArrayUtils';\nimport { INVERTED_DEFAULT_COLOR } from 'browser/renderer/atlas/Constants';\nimport { is256Color } from './atlas/CharAtlasUtils';\nimport { DEFAULT_COLOR } from 'common/buffer/Constants';\nimport { Terminal } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\n\nconst enum VertexAttribLocations {\n  POSITION = 0,\n  SIZE = 1,\n  COLOR = 2,\n  UNIT_QUAD = 3\n}\n\nconst vertexShaderSource = `#version 300 es\nlayout (location = ${VertexAttribLocations.POSITION}) in vec2 a_position;\nlayout (location = ${VertexAttribLocations.SIZE}) in vec2 a_size;\nlayout (location = ${VertexAttribLocations.COLOR}) in vec3 a_color;\nlayout (location = ${VertexAttribLocations.UNIT_QUAD}) in vec2 a_unitquad;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec3 v_color;\n\nvoid main() {\n  vec2 zeroToOne = (a_position + (a_unitquad * a_size)) / u_resolution;\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_color = a_color;\n}`;\n\nconst fragmentShaderSource = `#version 300 es\nprecision lowp float;\n\nin vec3 v_color;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = vec4(v_color, 1);\n}`;\n\ninterface IVertices {\n  attributes: Float32Array;\n  selection: Float32Array;\n  count: number;\n}\n\nconst INDICES_PER_RECTANGLE = 8;\nconst BYTES_PER_RECTANGLE = INDICES_PER_RECTANGLE * Float32Array.BYTES_PER_ELEMENT;\n\nconst INITIAL_BUFFER_RECTANGLE_CAPACITY = 20 * INDICES_PER_RECTANGLE;\n\nexport class RectangleRenderer {\n\n  private _program: WebGLProgram;\n  private _vertexArrayObject: IWebGLVertexArrayObject;\n  private _resolutionLocation: WebGLUniformLocation;\n  private _attributesBuffer: WebGLBuffer;\n  private _projectionLocation: WebGLUniformLocation;\n  private _bgFloat!: Float32Array;\n  private _selectionFloat!: Float32Array;\n\n  private _vertices: IVertices = {\n    count: 0,\n    attributes: new Float32Array(INITIAL_BUFFER_RECTANGLE_CAPACITY),\n    selection: new Float32Array(3 * INDICES_PER_RECTANGLE)\n  };\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl: IWebGL2RenderingContext,\n    private _dimensions: IRenderDimensions\n  ) {\n    const gl = this._gl;\n\n    this._program = throwIfFalsy(createProgram(gl, vertexShaderSource, fragmentShaderSource));\n\n    // Uniform locations\n    this._resolutionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_resolution'));\n    this._projectionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_projection'));\n\n    // Create and set the vertex array object\n    this._vertexArrayObject = gl.createVertexArray();\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Setup a_unitquad, this defines the 4 vertices of a rectangle\n    const unitQuadVertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n    const unitQuadVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadVerticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, unitQuadVertices, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(VertexAttribLocations.UNIT_QUAD);\n    gl.vertexAttribPointer(VertexAttribLocations.UNIT_QUAD, 2, this._gl.FLOAT, false, 0, 0);\n\n    // Setup the unit quad element array buffer, this points to indices in\n    // unitQuadVertuces to allow is to draw 2 triangles from the vertices\n    const unitQuadElementIndices = new Uint8Array([0, 1, 3, 0, 2, 3]);\n    const elementIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementIndicesBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, unitQuadElementIndices, gl.STATIC_DRAW);\n\n    // Setup attributes\n    this._attributesBuffer = throwIfFalsy(gl.createBuffer());\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.enableVertexAttribArray(VertexAttribLocations.POSITION);\n    gl.vertexAttribPointer(VertexAttribLocations.POSITION, 2, gl.FLOAT, false, BYTES_PER_RECTANGLE, 0);\n    gl.vertexAttribDivisor(VertexAttribLocations.POSITION, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.SIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.SIZE, 2, gl.FLOAT, false, BYTES_PER_RECTANGLE, 2 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.SIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.COLOR);\n    gl.vertexAttribPointer(VertexAttribLocations.COLOR, 4, gl.FLOAT, false, BYTES_PER_RECTANGLE, 4 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.COLOR, 1);\n\n    this._updateCachedColors();\n  }\n\n  public render(): void {\n    const gl = this._gl;\n\n    gl.useProgram(this._program);\n\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    gl.uniformMatrix4fv(this._projectionLocation, false, PROJECTION_MATRIX);\n    gl.uniform2f(this._resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Bind attributes buffer and draw\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices.attributes, gl.DYNAMIC_DRAW);\n    gl.drawElementsInstanced(this._gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, this._vertices.count);\n\n    // Bind selection buffer and draw\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices.selection, gl.DYNAMIC_DRAW);\n    gl.drawElementsInstanced(this._gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, 3);\n  }\n\n  public onResize(): void {\n    this._updateViewportRectangle();\n  }\n\n  public setColors(): void {\n    this._updateCachedColors();\n    this._updateViewportRectangle();\n  }\n\n  private _updateCachedColors(): void {\n    this._bgFloat = this._colorToFloat32Array(this._colors.background);\n    this._selectionFloat = this._colorToFloat32Array(this._colors.selection);\n  }\n\n  private _updateViewportRectangle(): void {\n    // Set first rectangle that clears the screen\n    this._addRectangleFloat(\n      this._vertices.attributes,\n      0,\n      0,\n      0,\n      this._terminal.cols * this._dimensions.scaledCellWidth,\n      this._terminal.rows * this._dimensions.scaledCellHeight,\n      this._bgFloat\n    );\n  }\n\n  public updateSelection(model: ISelectionRenderModel, columnSelectMode: boolean): void {\n    const terminal = this._terminal;\n\n    if (!model.hasSelection) {\n      fill(this._vertices.selection, 0, 0);\n      return;\n    }\n\n    if (columnSelectMode) {\n      const startCol = model.startCol;\n      const width = model.endCol - startCol;\n      const height = model.viewportCappedEndRow - model.viewportCappedStartRow + 1;\n      this._addRectangleFloat(\n        this._vertices.selection,\n        0,\n        startCol * this._dimensions.scaledCellWidth,\n        model.viewportCappedStartRow * this._dimensions.scaledCellHeight,\n        width * this._dimensions.scaledCellWidth,\n        height * this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n      fill(this._vertices.selection, 0, INDICES_PER_RECTANGLE);\n    } else {\n      // Draw first row\n      const startCol = model.viewportStartRow === model.viewportCappedStartRow ? model.startCol : 0;\n      const startRowEndCol = model.viewportCappedStartRow === model.viewportCappedEndRow ? model.endCol : terminal.cols;\n      this._addRectangleFloat(\n        this._vertices.selection,\n        0,\n        startCol * this._dimensions.scaledCellWidth,\n        model.viewportCappedStartRow * this._dimensions.scaledCellHeight,\n        (startRowEndCol - startCol) * this._dimensions.scaledCellWidth,\n        this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n\n      // Draw middle rows\n      const middleRowsCount = Math.max(model.viewportCappedEndRow - model.viewportCappedStartRow - 1, 0);\n      this._addRectangleFloat(\n        this._vertices.selection,\n        INDICES_PER_RECTANGLE,\n        0,\n        (model.viewportCappedStartRow + 1) * this._dimensions.scaledCellHeight,\n        terminal.cols * this._dimensions.scaledCellWidth,\n        middleRowsCount * this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n\n      // Draw final row\n      if (model.viewportCappedStartRow !== model.viewportCappedEndRow) {\n        // Only draw viewportEndRow if it's not the same as viewportStartRow\n        const endCol = model.viewportEndRow === model.viewportCappedEndRow ? model.endCol : terminal.cols;\n        this._addRectangleFloat(\n          this._vertices.selection,\n          INDICES_PER_RECTANGLE * 2,\n          0,\n          model.viewportCappedEndRow * this._dimensions.scaledCellHeight,\n          endCol * this._dimensions.scaledCellWidth,\n          this._dimensions.scaledCellHeight,\n          this._selectionFloat\n        );\n      } else {\n        fill(this._vertices.selection, 0, INDICES_PER_RECTANGLE * 2);\n      }\n    }\n  }\n\n  public updateBackgrounds(model: IRenderModel): void {\n    const terminal = this._terminal;\n    const vertices = this._vertices;\n\n    let rectangleCount = 1;\n\n    for (let y = 0; y < terminal.rows; y++) {\n      let currentStartX = -1;\n      let currentBg = DEFAULT_COLOR;\n      for (let x = 0; x < terminal.cols; x++) {\n        const modelIndex = ((y * terminal.cols) + x) * 4;\n        const bg = model.cells[modelIndex + 2];\n        if (bg !== currentBg) {\n          // A rectangle needs to be drawn if going from non-default to another color\n          if (currentBg !== DEFAULT_COLOR) {\n            const offset = rectangleCount++ * INDICES_PER_RECTANGLE;\n            this._updateRectangle(vertices, offset, currentBg, currentStartX, x, y);\n          }\n          currentStartX = x;\n          currentBg = bg;\n        }\n      }\n      // Finish rectangle if it's still going\n      if (currentBg !== DEFAULT_COLOR) {\n        const offset = rectangleCount++ * INDICES_PER_RECTANGLE;\n        this._updateRectangle(vertices, offset, currentBg, currentStartX, terminal.cols, y);\n      }\n    }\n    vertices.count = rectangleCount;\n  }\n\n  private _updateRectangle(vertices: IVertices, offset: number, bg: number, startX: number, endX: number, y: number): void {\n    let color: IColor | null = null;\n    if (bg === INVERTED_DEFAULT_COLOR) {\n      color = this._colors.foreground;\n    } else if (is256Color(bg)) {\n      color = this._colors.ansi[bg];\n    } else {\n      // TODO: Add support for true color\n      color = this._colors.foreground;\n    }\n    if (vertices.attributes.length < offset + 4) {\n      vertices.attributes = expandFloat32Array(vertices.attributes, this._terminal.rows * this._terminal.cols * INDICES_PER_RECTANGLE);\n    }\n    const x1 = startX * this._dimensions.scaledCellWidth;\n    const y1 = y * this._dimensions.scaledCellHeight;\n    const r = ((color.rgba >> 24) & 0xFF) / 255;\n    const g = ((color.rgba >> 16) & 0xFF) / 255;\n    const b = ((color.rgba >> 8 ) & 0xFF) / 255;\n\n    this._addRectangle(vertices.attributes, offset, x1, y1, (endX - startX) * this._dimensions.scaledCellWidth, this._dimensions.scaledCellHeight, r, g, b, 1);\n  }\n\n  private _addRectangle(array: Float32Array, offset: number, x1: number, y1: number, width: number, height: number, r: number, g: number, b: number, a: number): void {\n    array[offset    ] = x1;\n    array[offset + 1] = y1;\n    array[offset + 2] = width;\n    array[offset + 3] = height;\n    array[offset + 4] = r;\n    array[offset + 5] = g;\n    array[offset + 6] = b;\n    array[offset + 7] = a;\n  }\n\n  private _addRectangleFloat(array: Float32Array, offset: number, x1: number, y1: number, width: number, height: number, color: Float32Array): void {\n    array[offset    ] = x1;\n    array[offset + 1] = y1;\n    array[offset + 2] = width;\n    array[offset + 3] = height;\n    array[offset + 4] = color[0];\n    array[offset + 5] = color[1];\n    array[offset + 6] = color[2];\n    array[offset + 7] = color[3];\n  }\n\n  private _colorToFloat32Array(color: IColor): Float32Array {\n    return new Float32Array([\n      ((color.rgba >> 24) & 0xFF) / 255,\n      ((color.rgba >> 16) & 0xFF) / 255,\n      ((color.rgba >> 8 ) & 0xFF) / 255,\n      ((color.rgba      ) & 0xFF) / 255\n    ]);\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\n/**\n * A base class that can be extended to provide convenience methods for managing the lifecycle of an\n * object and its components.\n */\nexport abstract class Disposable implements IDisposable {\n  protected _disposables: IDisposable[] = [];\n  protected _isDisposed: boolean = false;\n\n  constructor() {\n  }\n\n  /**\n   * Disposes the object, triggering the `dispose` method on all registered IDisposables.\n   */\n  public dispose(): void {\n    this._isDisposed = true;\n    this._disposables.forEach(d => d.dispose());\n    this._disposables.length = 0;\n  }\n\n  /**\n   * Registers a disposable object.\n   * @param d The disposable to register.\n   */\n  public register<T extends IDisposable>(d: T): void {\n    this._disposables.push(d);\n  }\n\n  /**\n   * Unregisters a disposable object if it has been registered, if not do\n   * nothing.\n   * @param d The disposable to unregister.\n   */\n  public unregister<T extends IDisposable>(d: T): void {\n    const index = this._disposables.indexOf(d);\n    if (index !== -1) {\n      this._disposables.splice(index, 1);\n    }\n  }\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { CellData } from 'common/buffer/CellData';\nimport { FLAGS } from './Constants';\nimport { IBufferLine } from 'common/Types';\n\nexport function getCompatAttr(bufferLine: IBufferLine, index: number): number {\n  // TODO: Need to move WebGL over to the new system and remove this block\n  const cell = new CellData();\n  bufferLine.loadCell(index, cell);\n  const oldBg = cell.getBgColor() === -1 ? 256 : cell.getBgColor();\n  const oldFg = cell.getFgColor() === -1 ? 256 : cell.getFgColor();\n  const oldAttr =\n    (cell.isBold() ? FLAGS.BOLD : 0) |\n    (cell.isUnderline() ? FLAGS.UNDERLINE : 0) |\n    (cell.isBlink() ? FLAGS.BLINK : 0) |\n    (cell.isInverse() ? FLAGS.INVERSE : 0) |\n    (cell.isDim() ? FLAGS.DIM : 0) |\n    (cell.isItalic() ? FLAGS.ITALIC : 0);\n  const attrCompat =\n    oldBg |\n    (oldFg << 9) |\n    (oldAttr << 18);\n  return attrCompat;\n}\n"],"sourceRoot":""}